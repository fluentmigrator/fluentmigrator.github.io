{
  "articles/fluent-interface.html": {
    "href": "articles/fluent-interface.html",
    "title": "Fluent Interface | FluentMigrator documentation",
    "keywords": "Fluent Interface The FM fluent api allows you to create tables, columns, indexes and (nearly) every construct you need to manipulate your database structure. Behind the scenes, the fluent api populates a semantic model that FM uses to analyze and apply migrations in batch. The fluent api that is available in your Migration class starts with five main root expressions as follows: Create Expression Allows you to create a table, column, index, foreign key and schema. Create.Table(\"Users\") .WithIdColumn() // WithIdColumn is an extension, see below link. .WithColumn(\"Name\").AsString().NotNullable(); Create.ForeignKey() // You can give the FK a name or just let Fluent Migrator default to one .FromTable(\"Users\").ForeignColumn(\"CompanyId\") .ToTable(\"Company\").PrimaryColumn(\"Id\"); Example extensions can be found in the example MigrationExtensions.cs . Otherwise, you can replace WithIdColumn with .WithColumn(\"Id\").AsInt32().NotNullable().PrimaryKey().Identity(); Alter Expression Allows you to alter existing tables and columns. Alter.Table(\"Bar\") .AddColumn(\"SomeDate\") .AsDateTime() .Nullable(); Alter.Table(\"Bar\") .AlterColumn(\"SomeDate\") .AsDateTime() .NotNullable(); Alter.Column(\"SomeDate\") .OnTable(\"Bar\") .AsDateTime() .NotNullable(); Delete Expression Allows you to delete a table, column, foreign key and schema. Delete.Table(\"Users\"); Delete Multiple Columns Delete multiple columns from a table using the syntax in this expression: Delete.Column(\"AllowSubscription\").Column(\"SubscriptionDate\").FromTable(\"Users\"); Execute Expression Allows you to execute a block of sql, or a script by name (ie. myscript.sql) or an embedded sql script. To embed an sql script, add the file to your migration project and change the Build Action property to Embedded Resource. Execute.Script(\"myscript.sql\"); Execute.EmbeddedScript(\"UpdateLegacySP.sql\"); Execute.Sql(\"DELETE TABLE Users\"); Rename Expression Allows you to rename a column or table. Rename.Table(\"Users\").To(\"UsersNew\"); Rename.Column(\"LastName\").OnTable(\"Users\").To(\"Surname\"); Data Expressions Allows you to insert a row into a table using an anonymous type for the row's contents Insert.IntoTable(\"Users\").Row(new { FirstName = \"John\", LastName = \"Smith\" }); Delete.FromTable(\"Users\").AllRows(); // delete all rows Delete.FromTable(\"Users\").Row(new { FirstName = \"John\" }); // delete all rows with FirstName==John Delete.FromTable(\"Users\").IsNull(\"Username\"); //Delete all rows where Username is null Update.Table(\"Users\").Set(new { Name = \"John\" }).Where(new { Name = \"Johnanna\" }); Insert data as an non-Unicode string If you want to insert a string as non-Unicode (ANSI) then use the NonUnicodeString class: Insert.IntoTable(\"TestTable\").Row(new { Name = new NonUnicodeString(\"ansi string\") }); AllRows() Method A common task is to add a non-nullable column without a default value. One way this can be achieved is with the 'AllRows' method, via these three steps: Add new nullable column. Alter.Table(\"Bar\") .AddColumn(\"SomeDate\") .AsDateTime() .Nullable(); Update all rows to an initial value using the AllRows method. Update.Table(\"Bar\") .Set(new { SomeDate = DateTime.Today }) .AllRows(); Change the column to be non-nullable. Alter.Table(\"Bar\") .AlterColumn(\"SomeDate\") .AsDateTime() .NotNullable(); SetExistingRowsTo alternative to AllRows()` As of version 1.3.0, this can be done with a single statement using the SetExistingRowsTo method. Alter.Table(\"Bar\") .AddColumn(\"SomeDate\") .AsDateTime() .SetExistingRowsTo(DateTime.Today) .NotNullable(); IfDatabase Expression Allows for conditional expressions depending on database type. The current database types supported are: Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver. Multiple database types (as specified above) can be passed into the IfDatabase Expression (see Dealing with multiple database types for more details). IfDatabase(\"SqlServer\", \"Postgres\") .Create.Table(\"Users\") .WithIdColumn() .WithColumn(\"Name\").AsString().NotNullable(); IfDatabase(\"Sqlite\") .Create.Table(\"Users\") .WithColumn(\"Id\").AsInt16().PrimaryKey() .WithColumn(\"Name\").AsString().NotNullable(); Schema.Exists Expressions You can write migrations conditional on the pre-existing schema, which comes in handy for getting you out of certain jams. For instance, if you need to make a column but aren't sure if it already exists: if (!Schema.Table(\"Users\").Column(\"FirstName\").Exists()) { this.Create.Column(\"FirstName\").OnTable(\"Users\").AsAnsiString(128).Nullable(); } Next up, Profiles are migrations that if specified, will always run regardless of what other migrations run."
  },
  "articles/quickstart.html": {
    "href": "articles/quickstart.html",
    "title": "Starting with FluentMigrator | FluentMigrator documentation",
    "keywords": "Creating a project dotnet new console --name test Adding the NuGet packages # For migration development dotnet add package FluentMigrator # For migration execution dotnet add package FluentMigrator.Runner # For database support dotnet add package FluentMigrator.Runner.SQLite # ADO.NET support for the database dotnet add package Microsoft.Data.Sqlite Note In versions older than 4.0, the FluentMigrator.Runner package references all database-specific packages due to backwards compatibility reasons. Creating your first migration Create a file called 20180430_AddLogTable.cs with the following contents: using FluentMigrator; namespace test { [Migration(20180430121800)] public class AddLogTable : Migration { public override void Up() { Create.Table(\"Log\") .WithColumn(\"Id\").AsInt64().PrimaryKey().Identity() .WithColumn(\"Text\").AsString(); } public override void Down() { Delete.Table(\"Log\"); } } } This will create a table named Log with the columns Id , and Text . Running your first migration You have two options to execute your migration: Using an in-process runner (preferred) Using an out-of-process runner (for some corporate requirements) In-Process (preferred) Out-of-process (for some corporate requirements) Note If you are potentially running migrations from multiple application servers, such as a load balanced set of web servers, you will need to acquire a distributed and exclusive lock, either by database-dependent means or through the use of an external distributed lock coordinator. See the FAQ for more information . Change your Program.cs to the following code: using System; using System.Linq; using FluentMigrator.Runner; using FluentMigrator.Runner.Initialization; using Microsoft.Extensions.DependencyInjection; namespace test { class Program { static void Main(string[] args) { var serviceProvider = CreateServices(); // Put the database update into a scope to ensure // that all resources will be disposed. using (var scope = serviceProvider.CreateScope()) { UpdateDatabase(scope.ServiceProvider); } } /// <summary> /// Configure the dependency injection services /// </summary> private static IServiceProvider CreateServices() { return new ServiceCollection() // Add common FluentMigrator services .AddFluentMigratorCore() .ConfigureRunner(rb => rb // Add SQLite support to FluentMigrator .AddSQLite() // Set the connection string .WithGlobalConnectionString(\"Data Source=test.db\") // Define the assembly containing the migrations .ScanIn(typeof(AddLogTable).Assembly).For.Migrations()) // Enable logging to console in the FluentMigrator way .AddLogging(lb => lb.AddFluentMigratorConsole()) // Build the service provider .BuildServiceProvider(false); } /// <summary> /// Update the database /// </summary> private static void UpdateDatabase(IServiceProvider serviceProvider) { // Instantiate the runner var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); // Execute the migrations runner.MigrateUp(); } } } As you can see, instantiating the migration runner (in UpdateDatabase ) becomes very simple and updating the database is straight-forward. Important You need at least the .NET Core 2.1 preview 2 SDK for this tool. Install the dotnet-fm tool: dotnet tool install -g FluentMigrator.DotNet.Cli Execute the migration: dotnet fm migrate -p sqlite -c \"Data Source=test.db\" -a \".\\bin\\Debug\\netcoreapp2.1\\test.dll\" Tip You probably have to replace netcoreapp2.1 with the correct target framework. You can find it in the csproj file, XML element TargetFramework ."
  },
  "articles/version-table-metadata.html": {
    "href": "articles/version-table-metadata.html",
    "title": "Custom metadata for the VersionInfo table | FluentMigrator documentation",
    "keywords": "Custom metadata for the VersionInfo table By implementing the IVersionTableMetaData interface you can change the defaults for the VersionInfo table. The interface exposes six properties: Property Default value Description SchemaName (empty) The schema where the version table is stored TableName \"VersionInfo\" The table where the version information is stored ColumnName \"Version\" The name of the column where the version numbers are stored DescriptionColumnName \"Description\" The name of the last migration applied AppliedOnColumnName \"AppliedOn\" The datetime of when the last migration was applied UniqueIndexName \"UC_Version\" The name of the unique constraint for the version column In the same assembly that your migrations are located, create a new class (it must be public) that implements the IVersionTableMetaData interface and decorate the class with the VersionTableMetaDataAttribute . FluentMigrator will automatically find this and use it instead of the default settings. Note The custom IVersionTableMetaData is filtered by the values in the TypeFilterOptions . This allows different IVersionTableMetaData for every database. A common use case is changing the default schema so that you can have a migration assembly per schema. using FluentMigrator.Runner.VersionTableInfo; namespace Migrations { [VersionTableMetaData] public class CustomVersionTableMetaData : IVersionTableMetaData { public virtual string SchemaName => \"\"; public virtual string TableName => \"VersionInfo\"; public virtual string ColumnName => \"Version\"; public virtual string UniqueIndexName => \"UC_Version\"; public virtual string AppliedOnColumnName => \"AppliedOn\"; public virtual string DescriptionColumnName => \"Description\"; public virtual bool OwnsSchema => true; } } Finally, register it via Microsoft Dependency Injection: serviceCollection.AddScoped(typeof(IVersionTableMetaData), typeof(CustomVersionTableMetaData)); Overriding the DefaultVersionTableMetaData class If you want to keep most of the default values and just change one or two of the properties. Then you can create a class that inherits from DefaultVersionTableMetaData and override the property to be changed. Don't forget to add the VersionTableMetaData attribute to the class. [VersionTableMetaData] public class VersionTable : DefaultVersionTableMetaData { public override string ColumnName { get { return \"Version\"; } } } Finally, register it via Microsoft Dependency Injection: serviceCollection.AddScoped(typeof(IVersionTableMetaData), typeof(VersionTable));"
  },
  "articles/migration-constraints.html": {
    "href": "articles/migration-constraints.html",
    "title": "Migration Constraints | FluentMigrator documentation",
    "keywords": "Migration Constraints Overview Migration constraints allow users to run migrations based on dynamically evaluated conditions. Use Case The FluentMigrator.Runner.Core namespace has an example, CurrentVersionMigrationConstraintAttribute . Examples The FluentMigrator samples folder has a demonstration of this example: using FluentMigrator.Runner.Constraints; namespace FluentMigrator.Example.Migrations { /// <summary> /// Update notes. /// </summary> /// <remarks> /// This is only run when the migration 20090906205440 was already applied to the database. /// </remarks> [Migration(20190416112000)] [CurrentVersionMigrationConstraint(20090906205440)] public class UpdateNotesByScript : Migration { /// <inheritdoc /> public override void Up() { Execute.Sql(@\"/* this is a test script */ update Notes set body=body || ' (modified)'; \"); } /// <inheritdoc /> public override void Down() { // Nothing to do here } } } Caveats The downside to migration constraints, and `CurrentVersionMigrationConstraintAttribute in particular, is that some data is only loaded by FluentMigrator once. For example, version metadata is snapshot once. This is because FluentMigrator builds a list of all migrations to run, once, and then runs them. Thus, you can imagine a scenario where the above example is run, and during the migration run, version 20090906205440 executes. However, UpdateNotesByScript won't execute, because when the runner initializes, 20090906205440 wasn't yet applied to the database."
  },
  "articles/faq.html": {
    "href": "articles/faq.html",
    "title": "FAQ | FluentMigrator documentation",
    "keywords": "This FAQ will answer most common questions. Please open an issue if your question isn't answered here. Why does the Migrate.exe tool say No migrations found ? Possible reasons: Migration class isn't public Migration class isn't derived from IMigration (or Migration ) Migration class isn't attributed with MigrationAttribute The versions of the Migrate.exe tool ( FluentMigrator.Console package) and the FluentMigrator package(s) referenced in your project are different. How can I run FluentMigrator.DotNet.Cli with a .NET 5.0 assembly? The FluentMigrator.DotNet.Cli contains an --allowDirtyAssemblies switch that will allow you to load your 5.0 assemblies in a .NET Core 3.1 context. We're working on .NET 5.0 support.' Why do I get System.IO.FileLoadException: Could not load file or assembly 'FluentMigrator ... ? If you get a stack trace like the following: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.IO.FileLoadException: Could not load file or assembly 'FluentMigrator, Version=3.2.1.0, Culture=neutral, PublicKeyToken=aacfc7de5acabf05\". Could not find or load specific file. Then the most likely explanation is that you installed the FluentMigrator.DotNet.Cli command line tool globally, with a specific FluentMigrator.dll version in your global tool directory, and are loading a migrations assembly that references a different version of FluentMigrator.dll. The common workaround is to install the tool locally, rather than globally (applies to .NET Core SDK 3.0 and later). What are the supported databases? Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver. How can I run migrations safely from multiple application servers? Many server-side applications are load balanced and run multiple instances of the same application simultaneously from multiple web servers. In such a scenarios, if you choose to run migrations in-process (as opposed to an external migration runner), then there is an added risk of multiple processes trying to run migrations at the same time. FluentMigrator does not automatically handle this scenario because the default transactional behavior is not enough to guarantee that only a single process can be running migrations at any given time. There are, however, some workarounds. Database-Dependent Application Locking This style of solution depends upon MaintenanceMigrations. Two Maintenance Migrations are created: One with BeforeAll to atomically acquire a lock, and one AfterAll stage to release the lock. This example is for SQL Server 2008 and above and uses sp_getapplock to aquire a named lock before all migrations are run, and sp_releaseapplock to release the lock after all migrations are finished. [Maintenance(MigrationStage.BeforeAll, TransactionBehavior.None)] public class DbMigrationLockBefore : Migration { public override void Down() { throw new NotImplementedException(\"Down migrations are not supported for sp_getapplock\"); } public override void Up() { Execute.Sql(@\" DECLARE @result INT EXEC @result = sp_getapplock 'MyApp', 'Exclusive', 'Session' IF @result < 0 BEGIN DECLARE @msg NVARCHAR(1000) = 'Received error code ' + CAST(@result AS VARCHAR(10)) + ' from sp_getapplock during migrations'; THROW 99999, @msg, 1; END \"); } } [Maintenance(MigrationStage.AfterAll, TransactionBehavior.None)] public class DbMigrationUnlockAfter : Migration { public override void Down() { throw new NotImplementedException(\"Down migrations are not supported for sp_releaseapplock\"); } public override void Up() { Execute.Sql(\"EXEC sp_releaseapplock 'MyApp', 'Session'\"); } } In the above SQL Server example, we need to use TransactionBehavior.None on the Maintenance Migration while specifying the @LockOwner parameter to Session , which means that the locking behavior applies to the entire Session rather than a single transaction. While the above is specific to SQL Server, similar concepts may available in other database providers. PostgreSQL has Advisory Locks SQL Anywhere has Schema Locks Oracle has DBMS_LOCK.ALLOCATE_UNIQUE DB2 has LOCK TABLESPACE (with the caveat that every table in your migration is in the same tablespace) External Distributed Lock If your database doesn't provide a means of acquiring an exclusive lock for migrations, it is still possible to achieve this functionality by using an external service for acquiring a distributed lock. For example, Redis provides a way to perform Distributed locks so that different processes can operate on a shared resource in a mutually exclusive way. This scenario can be baked into a BeforeAll / AfterAll pair of Maintenance Migrations, as demonstrated above, to acquire an exclusive lock for the duration of the migration running. As an alternative to Maintenance Migrations, which are by necessity specified in different classes, you could simply wrap the MigrateUp() call in code that acquires and releases the lock. Consider this pseudo-code which relies on RedLock.net : async RunMigrationsWithDistributedLock(IMigrationRunner runner) { var resource = \"my-app-migrations\"; var expiry = TimeSpan.FromMinutes(5); using (var redLock = await redlockFactory.CreateLockAsync(resource, expiry)) // there are also non async Create() methods { // make sure we got the lock if (redLock.IsAcquired) { runner.MigrateUp(); } } // the lock is automatically released at the end of the using block } How can I execute a stored procedure using Oracle? If you get ORA-00900: Invalid SQL Statement when executing a stored procedure, then chances are you need to wrap your stored procedure in a PLSQL block: Execute.Sql(\"DBMS_UTILITY.EXEC_DDL_STATEMENT('Create Index Member_AddrId On Member(AddrId)');\"); becomes: Execute.Sql(@\" BEGIN DBMS_UTILITY.EXEC_DDL_STATEMENT('Create Index Member_AddrId On Member(AddrId)'); END;\"); How do I get the name of a SQL Server database? Not all databases have a \"name\". Writing migrations that use a name therefore cannot be truly database-agnostic. That said, the following will show an example of getting the name so that you can perform an ALTER DATABASE command. Note that to ALTER DATABASE [YourDatabaseName] , you need to switch to the [master] database first via USE [master] . Then, since FluentMigrator does not call sp_reset_connection , you need to switch back to the database being migrated. If you do not, the ensuing migrations will be run in the wrong database! In the below example, we show how to enter a SQL Server database into single-user mode, in order to perform some maintenace tasks. Use dynamic SQL: public class EnterDatabaseSingleUserModeState : Migration { public override void Up() { /* Before you set the database to SINGLE_USER, verify that the AUTO_UPDATE_STATISTICS_ASYNC option is set to OFF. When this option is set to ON, the background thread that is used to update statistics takes a connection against the database, and you will be unable to access the database in single-user mode. For more information, see ALTER DATABASE SET Options (Transact-SQL). */ this.Execute.Sql(@\" DECLARE @DbName sysname = DB_NAME(); DECLARE @SqlCommand NVARCHAR(MAX) = ' USE [master]; SET DEADLOCK_PRIORITY 10; DECLARE @AutoUpdateStatisticsAsync BIT = CAST(0 AS BIT); IF EXISTS ( SELECT NULL FROM sys.databases WHERE name = @DbName AND is_auto_update_stats_async_on = CAST(1 AS BIT) ) BEGIN ALTER DATABASE [' + @DbName + '] SET AUTO_UPDATE_STATISTICS_ASYNC OFF; SET @AutoUpdateStatisticsAsync = CAST(1 AS BIT); END; ALTER DATABASE [' + @DbName + ']' + ' SET SINGLE_USER WITH ROLLBACK IMMEDIATE; -- Here is where you put your administrative commands. IF (@AutoUpdateStatisticsAsync = 1) BEGIN ALTER DATABASE [' + @DbName + '] SET AUTO_UPDATE_STATISTICS_ASYNC ON; END; '; EXEC(@SqlCommand); SET @SqlCommand NVARCHAR(MAX) = 'USE [' + @DbName + ']'; EXEC(@SqlCommand); \"); } Certificate error for SQL Connection Since the use of Microsoft.Data.SqlClient version 4.0.0 connections are encrypted by default in .NET. You might start getting the exception: A connection was successfully established with the server, but then an error occurred during the login process. (provider: SSL Provider, error: 0 - The certificate chain was issued by an authority that is not trusted.) . If fixing a valid certificate isn't a feasable path, you can always disable the encryption by adding Encrypt=False to the connection string. Then the connection won't be encryptet, and thus no certificate needed. As a note; you can also add TrustServerCertificate=True to the connection string, if you have a self-signed certificate or similar. But it's probably a better idea to fix a real certificate, or skip encryption all together. SQLite specific topics Connection Pooling When working with FluentMigrator with the SQLite processor, by default SQLite will run with connection pooling enabled. When connection pooling is enabled, SQLite will keep a lock on the database file even after connection.Close() is called on the relevant DB connection. This is important to know in case you need to perform any cleanup after FluentMigrator has run where deleting the database file is required. In this scenario you would receive an IO exception if you attempt to delete or move the file as SQLite still has a lock on the file. You can disable connection pooling however by adding Pooling=False; as a parameter in your connection string. With pooling disabled, you can then safely delete or move the database after the FluentMigrator processor is disposed."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Install from Nuget | FluentMigrator documentation",
    "keywords": "Install from Nuget The project is split into multiple packages: Package Description FluentMigrator The base assembly needed to create migrations FluentMigrator.Runner The runner classes required for in-process execution of migrations FluentMigrator.Console The .NET 4.0/4.5/.NET Core 2.0 executable for out-of-process execution of migrations FluentMigrator.MSBuild The .NET 4.0/4.5/.NET Standard 2.0 task for MSBuild FluentMigrator.DotNet.Cli The .NET Core 2.1 executable that integrates into the .NET Core CLI tooling ( dotnet command) Getting Started Check out the tour of FluentMigrator in our Quickstart We also started a FAQ Usage details How to create a migration Learn about the fluent interface Profiles can be used to seed test data And then choose one of the migration runners to run your migrations More Features Database functions as default value Microsoft SQL Server specific extensions Using raw SQL Auto-reversing migrations Transaction modes for the migration runner Advanced Features and Techniques of FluentMigrator Dealing with multiple database types Filter migrations run based on Tags Enforcing migration version numbering rules Create custom metadata for the VersionInfo table Current Release Release Notes Upgrade guides 3.1 to 3.2 3.0 to 3.1 2.x to 3.0 Runners Console dotnet-fm Supported databases For the current release these are the supported databases: Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver."
  },
  "api/v3.x/index.html": {
    "href": "api/v3.x/index.html",
    "title": "FluentMigrator API | FluentMigrator documentation",
    "keywords": "FluentMigrator API The most important part of the API is the migration runner . Getting started The starting point for every beginner of FluentMigrator is the Quickstart tutorial ."
  },
  "articles/technical/fluent-api-alter.html": {
    "href": "articles/technical/fluent-api-alter.html",
    "title": "Fluent API (Alter) | FluentMigrator documentation",
    "keywords": "Alter ( IAlterExpressionRoot ) Alter --+- Table --- name ----> IAlterTableAddColumnOrAlterColumnOrSchemaOrDescriptionSyntax | +- Column --- name ---> IAlterColumnOnTableSyntax IAlterTableAddColumnOrAlterColumnOrSchemaOrDescriptionSyntax --------+-----------------------------------+--> IAlterTableAddColumnOrAlterColumnOrSchemaSyntax | | +- WithDescription --- description -+ IAlterColumnOnTableSyntax ---------- OnTable --- name --> IAlterColumnAsTypeOrInSchemaSyntax IAlterColumnAsTypeOrInSchemaSyntax --------+-----------------------+--> IAlterColumnAsTypeSyntax | | +- InSchema --- schema -+ IAlterColumnAsTypeSyntax ---------- IColumnTypeSyntax ---- TNext: IAlterColumnOptionSyntax --- IColumnTypeSyntax IAlterColumnOptionSyntax ---------- IColumnOptionSyntax -+--> TNext: IAlterColumnOptionSyntax | +--> TNextFk: IAlterColumnOptionOrForeignKeyCascadeSyntax IColumnOptionSyntax IAlterColumnOptionOrForeignKeyCascadeSyntax --------+--> IAlterColumnOptionSyntax | +- IForeignKeyCascadeSyntax -+--> TNext: IAlterColumnOptionSyntax | +--> TNextFk: IAlterColumnOptionOrForeignKeyCascadeSyntax IForeignKeyCascadeSyntax IAlterTableAddColumnOrAlterColumnOrSchemaSyntax --------+-----------------------+--> IAlterTableAddColumnOrAlterColumnSyntax | | +- InSchema --- schema -+ IAlterTableAddColumnOrAlterColumnSyntax --------+- AddColumn name ---+--> IAlterTableColumnAsTypeSyntax | | +- AlterColumn name -+ | +- ToSchema name -------| (end) IAlterTableColumnAsTypeSyntax ---------- IColumnTypeSyntax ---- TNext: IAlterTableColumnOptionOrAddColumnOrAlterColumnSyntax --- IColumnTypeSyntax IAlterTableColumnOptionOrAddColumnOrAlterColumnSyntax --------+-------------------------------+--+--> IAlterTableAddColumnOrAlterColumnSyntax | | | +- SetExistingRowsTo --- value -+ +--> IColumnOptionSyntax -+--> TNext: IAlterTableColumnOptionOrAddColumnOrAlterColumnSyntax | +--> TNextFk: IAlterTableColumnOptionOrAddColumnOrAlterColumnOrForeignKeyCascadeSyntax IColumnOptionSyntax IAlterTableColumnOptionOrAddColumnOrAlterColumnOrForeignKeyCascadeSyntax --------+--> IAlterTableColumnOptionOrAddColumnOrAlterColumnSyntax | +- IForeignKeyCascadeSyntax -+--> TNext: IAlterTableColumnOptionOrAddColumnOrAlterColumnSyntax | +--> TNextFk: IAlterTableColumnOptionOrAddColumnOrAlterColumnOrForeignKeyCascadeSyntax IForeignKeyCascadeSyntax"
  },
  "articles/technical/fluent-api-create.html": {
    "href": "articles/technical/fluent-api-create.html",
    "title": "Fluent API (Create) | FluentMigrator documentation",
    "keywords": "ICreateExpressionRoot Create -+- Schema ------------- name --- ICreateSchemaOptionsSyntax --- | +- Table -------------- name --- ICreateTableWithColumnOrSchemaOrDescriptionSyntax --- | +- Column ------------- name --- ICreateColumnOnTableSyntax --- | +- ForeignKey -------+--------+- ICreateForeignKeyFromTableSyntax --- | | | | +- name -+ | +- Index ------------+--------+- ICreateIndexForTableSyntax --- | | | | +- name -+ | +- Sequence ----------- name --- ICreateSequenceInSchemaSyntax --- | +- PrimaryKey -------+--------+- ICreateConstraintOnTableSyntax --- | | | | +- name -+ | +- UniqueConstraint -+--------+- ICreateConstraintOnTableSyntax --- | | +- name -+ ICreateSchemaOptionsSyntax ICreateTableWithColumnOrSchemaOrDescriptionSyntax ICreateColumnOnTableSyntax ICreateForeignKeyFromTableSyntax ICreateIndexForTableSyntax ICreateSequenceInSchemaSyntax ICreateConstraintOnTableSyntax Schema ICreateSchemaOptionsSyntax Note Extension point Table ICreateTableWithColumnOrSchemaOrDescriptionSyntax --------+-----------------------------+- ICreateTableWithColumnOrSchemaSyntax --- | | +- WithDescription ---- name -+ ICreateTableWithColumnOrSchemaSyntax --------+-----------------------------+- ICreateTableWithColumnSyntax --- | | +- InSchema ----------- name -+ ICreateTableWithColumnSyntax ---------- WithColumn --------- name --- ICreateTableColumnAsTypeSyntax --- ICreateTableColumnAsTypeSyntax ---------- IColumnTypeSyntax ---- TNext: ICreateTableColumnOptionOrWithColumnSyntax --- IColumnTypeSyntax ICreateTableColumnOptionOrWithColumnSyntax --------+- ICreateTableWithColumnSyntax -------------------------------------------------------------------+- | | +- IColumnOptionSyntax -+- TNext: ICreateTableColumnOptionOrWithColumnSyntax ----------------------+ | | +- TNextFk: ICreateTableColumnOptionOrForeignKeyCascadeOrWithColumnSyntax -+ IColumnOptionSyntax ICreateTableColumnOptionOrForeignKeyCascadeOrWithColumnSyntax --------+--> ICreateTableColumnOptionOrWithColumnSyntax | +- IForeignKeyCascadeSyntax -+--> TNext: ICreateTableColumnOptionOrWithColumnSyntax | +--> TNextFk: ICreateTableColumnOptionOrForeignKeyCascadeOrWithColumnSyntax IForeignKeyCascadeSyntax Column ICreateColumnOnTableSyntax ---------- OnTable --- name ---> ICreateColumnAsTypeOrInSchemaSyntax ICreateColumnAsTypeOrInSchemaSyntax --------+---------------------+--> ICreateColumnAsTypeSyntax | | +- InSchema --- name -+ ICreateColumnAsTypeSyntax ---------- IColumnTypeSyntax ---> ICreateColumnOptionSyntax IColumnTypeSyntax ICreateColumnOptionSyntax ICreateColumnOptionSyntax --------+-------------------------------+- IColumnOptionSyntax -+--> TNext: ICreateColumnOptionSyntax | | | +- SetExistingRowsTo --- value -+ +--> TNextFk: ICreateColumnOptionOrForeignKeyCascadeSyntax IColumnOptionSyntax ICreateColumnOptionOrForeignKeyCascadeSyntax --------+--> ICreateColumnOptionSyntax | +- IForeignKeyCascadeSyntax -+--> TNext: ICreateColumnOptionSyntax | +--> TNextFk: ICreateColumnOptionOrForeignKeyCascadeSyntax IForeignKeyCascadeSyntax ForeignKey ICreateForeignKeyFromTableSyntax ---------- FromTable --- table ---> ICreateForeignKeyForeignColumnOrInSchemaSyntax ICreateForeignKeyForeignColumnOrInSchemaSyntax --------+---------------------+--> ICreateForeignKeyForeignColumnSyntax | | +- InSchema --- name -+ ICreateForeignKeyForeignColumnSyntax --------+- ForeignColumn --- column ---+--> ICreateForeignKeyToTableSyntax | | +- ForeignColumns --- columns -+ ICreateForeignKeyToTableSyntax ---------- ToTable name --> ICreateForeignKeyPrimaryColumnOrInSchemaSyntax ICreateForeignKeyPrimaryColumnOrInSchemaSyntax --------+-----------------+--> ICreateForeignKeyPrimaryColumnSyntax | | +- InSchema name -+ ICreateForeignKeyPrimaryColumnSyntax --------+- PrimaryColumn --- column ---+--> ICreateForeignKeyCascadeSyntax | | +- PrimaryColumns --- columns -+ ICreateForeignKeyCascadeSyntax --------+- OnDeleteOrUpdate --- rule ----| (end) | +- OnDelete --- rule ---------+--> ICreateForeignKeyCascadeSyntax | | +- OnUpdate --- rule ---------+ Index ICreateIndexForTableSyntax ---------- OnTable --- name ---> ICreateIndexOnColumnOrInSchemaSyntax ICreateIndexOnColumnOrInSchemaSyntax --------+---------------------+--> ICreateIndexOnColumnSyntax | | +- InSchema --- name -+ ICreateIndexOnColumnSyntax --------+- OnColumn --- name ---> ICreateIndexColumnOptionsSyntax | +- WithOptions ---------> ICreateIndexOptionsSyntax ICreateIndexColumnOptionsSyntax --------+- Ascending --+--> ICreateIndexMoreColumnOptionsSyntax | | +- Descending -+ | +- Unique --------> ICreateIndexColumnUniqueOptionsSyntax ICreateIndexOptionsSyntax --------+- Unique -------+--> ICreateIndexOnColumnSyntax | | +- NonClustered -+ | | +- Clustered ----+ ICreateIndexOnColumnSyntax ICreateIndexMoreColumnOptionsSyntax Note Extension point --------+---------------------+--> ICreateIndexOnColumnSyntax | | +- get_CurrentColumn -+ ICreateIndexOnColumnSyntax ICreateIndexColumnUniqueOptionsSyntax Note Extension point --------+---------------------+--> ICreateIndexOnColumnSyntax | | +- get_CurrentColumn -+ ICreateIndexOnColumnSyntax Sequence ICreateSequenceInSchemaSyntax --------+---------------------+--> ICreateSequenceSyntax | | +- InSchema --- name -+ ICreateSequenceSyntax --------+-----------------------------+--> ICreateSequenceSyntax | | +- IncrementBy --- increment -+ | | +- MinValue --- minValue -----+ | | +- MaxValue --- maxValue -----+ | | +- StartWith --- startWith ---+ | | +- Cache --- value -----------+ | | +- Cycle ---------------------+ PrimaryKey/Unique Constraint ICreateConstraintOnTableSyntax ---------- OnTable --- name ----> ICreateConstraintWithSchemaOrColumnSyntax ICreateConstraintWithSchemaOrColumnSyntax --------+- ICreateConstraintColumnsSyntax | +- ICreateConstraintWithSchemaSyntax Expanded: --------+-----------------------+--+- Column --- name ---+--> ICreateConstraintOptionsSyntax | | | | +- WithSchema --- name -+ +- Columns --- names -+ ICreateConstraintColumnsSyntax --------+- Column --- name ---+--> ICreateConstraintOptionsSyntax | | +- Columns --- names -+ ICreateConstraintWithSchemaSyntax ---------- WithSchema --- name ----> ICreateConstraintColumnsSyntax ICreateConstraintOptionsSyntax Note Extension point"
  },
  "articles/technical/fluent-api-delete.html": {
    "href": "articles/technical/fluent-api-delete.html",
    "title": "Fluent API (Delete) | FluentMigrator documentation",
    "keywords": "IDeleteExpressionRoot Delete -+- Schema ------------- name ----------| (end) | +- Table -------------- name -------+--> IInSchemaSyntax | | +- Sequence ----------- name -------+ | +- Column ------------- name ----------> IDeleteColumnFromTableSyntax | +- ForeignKey -------+-----------------> IDeleteForeignKeyFromTableSyntax | | | +- name ----------> IDeleteForeignKeyOnTableSyntax | +- FromTable ---------- name ----------> IDeleteDataOrInSchemaSyntax | +- Index ------------+--------+--------> IDeleteIndexForTableSyntax | | | | +- name -+ | +- PrimaryKey --------- name -------+--> IDeleteConstraintOnTableSyntax | | +- UniqueConstraint -+--------+-----+ | | | | +- name -+ | +- DefaultConstraint ------------------> IDeleteDefaultConstraintOnTableSyntax Generic IInSchemaSyntax ---------- InSchema --- name ---| (end) Column IDeleteColumnFromTableSyntax --------+- FromTable --- name ---> IInSchemaSyntax | +- Column --- name ------> IDeleteColumnFromTableSyntax ForeignKey IDeleteForeignKeyFromTableSyntax ---------- FromTable --- name ---> IDeleteForeignKeyForeignColumnOrInSchemaSyntax IDeleteForeignKeyForeignColumnOrInSchemaSyntax --------+-------------------+--> IDeleteForeignKeyForeignColumnSyntax | | +- InSchema name ---+ IDeleteForeignKeyForeignColumnSyntax --------+- ForeignColumn ---- name --+--> IDeleteForeignKeyToTableSyntax | | +- ForeignColumns --- names -+ IDeleteForeignKeyToTableSyntax ---------- ToTable --- name ---> IDeleteForeignKeyPrimaryColumnSyntax IDeleteForeignKeyPrimaryColumnSyntax --------+- PrimaryColumn ---- name --+--| (end) | | +- PrimaryColumns --- names -+ IDeleteForeignKeyOnTableSyntax ---------- OnTable --- name ---> IInSchemaSyntax Data IDeleteDataOrInSchemaSyntax --------+---------------------+--> IDeleteDataSyntax | | +- InSchema --- name -+ IDeleteDataSyntax --------+- Row --- anonymousType ----> IDeleteDataSyntax | +- AllRows ---------------+--| (end) | | +- IsNull --- columnName -+ Index IDeleteIndexForTableSyntax --------+- OnTable --- name ---> IDeleteIndexOnColumnOrInSchemaSyntax | +- WithOptions --------> IDeleteIndexOptionsSyntax IDeleteIndexOnColumnOrInSchemaSyntax --------+---------------------+--> IDeleteIndexOnColumnSyntax | | +- InSchema --- name -+ IDeleteIndexOnColumnSyntax --------+- OnColumn --- name ---+--> IDeleteIndexOptionsSyntax | | +- OnColumns --- names -+ | | +- WithOptions ---------+ IDeleteIndexOptionsSyntax Note Extension point PrimaryKey/Unique constraint IDeleteConstraintOnTableSyntax ---------- FromTable name ---> IDeleteConstraintInSchemaOptionsSyntax IDeleteConstraintInSchemaOptionsSyntax --------+---------------------+--> IDeleteConstraintColumnSyntax | | +- InSchema --- name -+ IDeleteConstraintColumnSyntax --------+- OnColumn --- name ---+--| (end) | | +- OnColumns --- names -+ DefaultConstraint IDeleteDefaultConstraintOnTableSyntax ---------- OnTable --- name ---> IDeleteDefaultConstraintOnColumnOrInSchemaSyntax IDeleteDefaultConstraintOnColumnOrInSchemaSyntax --------+---------------------+--> IDeleteDefaultConstraintOnColumnSyntax | | +- InSchema --- name -+ IDeleteDefaultConstraintOnColumnSyntax ---------- OnColumn --- name ---| (end)"
  },
  "articles/technical/fluent-api.html": {
    "href": "articles/technical/fluent-api.html",
    "title": "Fluent API | FluentMigrator documentation",
    "keywords": "How does the fluent API work? The starting points for the fluent API are the following classes: MigrationBase : database modelling Migration : data modification and script execution Supported expressions Create Create a database object. Alter Alter a database object. Delete Delete a database object or data. Rename ( IRenameExpressionRoot ) Rename a database object. Schema ( ISchemaExpressionRoot ) Schema-oriented starting point for expressions. IfDatabase ( IIfDatabaseExpressionRoot ) Create database-specific expressions. Insert ( IInsertExpressionRoot ) Insert data. Update ( IUpdateExpressionRoot ) Update data. Execute ( IExecuteExpressionRoot ) Execute SQL statements/scripts. Planned changes Differentiate between Delete and Drop"
  },
  "articles/runners/runner-console.html": {
    "href": "articles/runners/runner-console.html",
    "title": "Command Line Runner | FluentMigrator documentation",
    "keywords": "Command Line Runner Options Migrate.exe can be called with the following parameters. The first three parameters are required if running a migration. A lot of the parameters have more than one switch for the same parameter. If a parameter has an = sign after it, then it expects some text value to be set, otherwise it is just a boolean switch e.g. the preview parameter. When writing the command, the = sign is optional (e.g. --task=migrate or --task migrate ). Single dashes or double dashes is also optional e.g. -task or --task . Examples: Migrate.exe /conn \"Data Source=db\\db.sqlite;Version=3;\" /provider sqlite /assembly your.migrations.dll /verbose migrate --conn \"server=.\\SQLEXPRESS;uid=testfm;pwd=test;Trusted_Connection=yes;database=FluentMigrator\" --provider sqlserver2008 --assembly \"..\\Migrations\\bin\\Debug\\Migrations.dll\" --task migrate --output --outputFilename migrated.sql migrate -c \"server=.\\SQLEXPRESS;uid=testfm;pwd=test;Trusted_Connection=yes;database=FluentMigrator\" -db sqlserver2008 -a \"..\\Migrations\\bin\\Debug\\Migrations.dll\" -t migrate -o -of migrated.sql --assembly, -a, --target=VALUE (required) The assembly containing the migrations you want to execute. --provider, --dbtype, --db=VALUE (required) The kind of database you are migrating against. Available choices are: Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver. --connectionString, --connection, --conn, -c=VALUE (required, can be a connectionStringName ) The connection string to the server and database you want to execute your migrations against. This can be a full connection string or the name of the connection string stored in a config file. When specifying a named connection string, FluentMigrator searches for it in this order: The specified config file via --connectionStringConfigPath ](#cscp) parameter Target assembly's config file Machine.config config file --connectionStringConfigPath, --configPath=VALUE The absolute path of the config file where the connection string named by is found. This parameter is used together with the --connectionString parameter, the --connectionString parameter specifies the name of the connection string in the config file. If the config file looks like this: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <connectionStrings> <clear /> <add name=\"SRVConnectionString\" connectionString=\"server=SQLEXPRESS;uid=test;pwd=test;database=FluentMigrator\"/> </connectionStrings> </configuration> Then the --connectionString parameter should be set to SRVConnectionString. If not specified, it defaults to lookup order specified in the --connectionString parameter documentation. Note: --connectionStringConfigPath uses absolute path, whereas --assembly uses relative path. --task, -t=VALUE (optional) The task you want FluentMigrator to perform. Available choices are: migrate:up migrate (same as migrate:up) migrate:down (used in conjunction with the --version switch. Warning: if you don't supply --version this will revert all migrations) rollback (per default this rollbacks one step. Use the --steps switch to rollback more steps) rollback:toversion (used in conjunction with the --version switch. Will rollback all versions down to the specified version, not including the specified version. The Migration attribute contains the version that should be used with the --version switch.) rollback:all listmigrations Default is 'migrate'. --verbose=VALUE (optional) Show the SQL statements generated and execution time in the console. Default is false. This should be a boolean switch but is not. VALUE can be anything to set to true and the switch should not be specified to set it to false. For example, --verbose qwerty would set it to true. --output, --out, -o (optional) Output generated SQL to a file. Default is no output. Use outputFilename to control the filename, otherwise [assemblyname].sql is the default. This is a boolean switch so it does not take a value. --outputFilename, --outfile, --of=VALUE (optional) The name of the file to output the generated SQL to. The output option must be included for output to be saved to the file. --outputSemicolonDelimiter, --outsemdel, -osd (optional) SQL statements in output file are delimited with a semicolon. --namespace, --ns=VALUE (optional) The namespace that contains the migrations you want to run. Default is all migrations found within the Target Assembly will be run. --nested (optional) Whether migrations in nested namespaces should be included. Used in conjunction with the namespace option. The default is false so that nested namespaces are not included. This is a boolean switch so it does not take a value. --steps=VALUE (optional) The number of versions to rollback if the task is 'rollback'. Default is 1. --preview, -p (optional) Only output the SQL generated by the migration - do not execute it. Default is false. This is a boolean switch so it does not take a value. --version=VALUE (optional) The specific version to migrate. Default is 0, which will run all migrations. The version of a migration is the unique identifier that is contained in the Migration attribute. For example, if a Migration has this attribute [Migration(201303062126)] then the version is 201303062126. --startVersion=VALUE The specific version to start migrating from. Only used when NoConnection is true. Should therefore only be used when generating an output file. Default is 0 --noConnection Indicates that migrations will be generated without consulting a target database. Should only be used when generating an output file. --profile=VALUE (optional) The \"profile\":https://github.com/schambers/fluentmigrator/wiki/Profiles to run after executing migrations. --timeout=VALUE (optional) Overrides the default SqlCommand timeout of 30 seconds. --workingdirectory, --wd=VALUE (optional) The directory to load SQL scripts specified by migrations from. --tag=VALUE Filters migrations to be run based on tags. See Filter migrations run based on tags . See also --include-untagged option. --include-untagged: Includes untagged migrations. By default, if you use --tag=VALUE to filter migrations to be run based on tags, untagged migrations will be excluded. --context=VALUE A string argument that can be used in a migration. See ApplicationContext: Passing parameters to Migrations --transaction-per-session, --tps (optional) The default transaction is one transaction per migration so the default for this switch is false. Run migrations in one transaction per session (task) instead. This is a boolean switch so it does not take a value. --stopOnError Pauses migration execution until the user input if any error occurred. Default is false. --allow-breaking-changes Allows execution of migrations marked as breaking changes. Default is false. --strip- Disables stripping of comments from executed SQL. Note the - at the end of the command. --help, -h, -? Displays help menu. --providerswitches=VALUE Specify provider specific options, for instance: (Oracle) QUOTEDIDENTIFIERS=TRUE , which will quote identifiers always (Firebird) Force Quote=true , which will quote identifiers always"
  },
  "articles/multi-db-support.html": {
    "href": "articles/multi-db-support.html",
    "title": "Dealing with Multiple Database Types | FluentMigrator documentation",
    "keywords": "Dealing with multiple database types FluentMigrator allows you to target multiple database types from the same migration project. Every FluentMigrator project is database agnostic and can be run against any of the supported database types. However, there are times when only some migrations in a project need to be executed against one of the database types. For supporting that scenario FluentMigrator includes the IfDatabase expression. Using IfDatabase Suppose you have a migration that executes a script file to create a view: public class CreateViewsMigration : Migration { public override void Up() { Execute.Script(\"CreateViewsMigrationUp.sql\"); } public override void Down() { Execute.Script(\"CreateViewsMigrationDown.sql\"); } } However the project needs to create some views in an SqlServer database and others in an Oracle database , but you want both tasks to be part of the same migration, sharing the same migration number in both databases. You handle this by creating scripts for each database and specifying which one needs to be executed: public class CreateViewsMigration : Migration { public override void Up() { IfDatabase(\"oracle\").Execute.Script(\"CreateViewsOracleMigrationUp.sql\"); IfDatabase(\"sqlserver\").Execute.Script(\"CreateViewsSqlServerMigrationUp.sql\"); } public override void Down() { IfDatabase(\"oracle\").Execute.Script(\"CreateViewsOracleMigrationDown.sql\"); IfDatabase(\"sqlserver\").Execute.Script(\"CreateViewsSqlServerMigrationDown.sql\"); } } Supported databases Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver."
  },
  "articles/comparison-to-entity-framework-migrations.html": {
    "href": "articles/comparison-to-entity-framework-migrations.html",
    "title": "FluentMigrator Comparison to Entity Framework Code-First Migrations | FluentMigrator documentation",
    "keywords": "Technically, FluentMigrator does not \"generate\" migrations for you. You have to write them yourself. By comparison, Entity Framework Core can use its fluent model building syntax and automatically infer up/down migrations, and you can focus primarily on writing data migrations. Entity Framework Core does this through PowerShell command-line interface Add-Migration , which keeps track of a ModelSnapshot state. That said, here is how Microsoft recommends writing migrations with EFCore, compared with the same logic in FluentMigrator: EFCore Source: https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/migrations?view=aspnetcore-3.1#examine-up-and-down-methods public partial class InitialCreate : Migration { protected override void Up(MigrationBuilder migrationBuilder) { migrationBuilder.CreateTable( name: \"Course\", columns: table => new { CourseID = table.Column<int>(nullable: false), Credits = table.Column<int>(nullable: false), Title = table.Column<string>(nullable: true) }, constraints: table => { table.PrimaryKey(\"PK_Course\", x => x.CourseID); }); // Additional code not shown } protected override void Down(MigrationBuilder migrationBuilder) { migrationBuilder.DropTable( name: \"Enrollment\"); // Additional code not shown } } FluentMigrator [Migration(1, \"InitialCreate\")] public class InitialCreate : Migration { public void Up() { Create.Table(\"Course\") .WithColumn(\"CourseID\").AsInt32().NotNullable().PrimaryKey() .WithColumn(\"Credits\").AsInt32().NotNullable() .WithColumn(\"Title\").AsString().Nullable(); // Additional code not shown } protected override void Down(MigrationBuilder migrationBuilder) { Delete.Table(\"Enrollment\"); // Additional code not shown } } In the above example, you don't need to type out PK_Course in your primary key definition, because FluentMigrator supports \"Don't Repeat Yourself\" principle via naming conventions and \"knows\" that is the correct name for your primary key. You just define your naming conventions once. Also, because of the fluent syntax, you'll find you have to type a lot less than you do with EFCore migrations. If you find this to not be the case, please provide feedback and we will make it more efficient."
  },
  "articles/migration-example.html": {
    "href": "articles/migration-example.html",
    "title": "Migrations | FluentMigrator documentation",
    "keywords": "Migrations The basic unit of FM is the Migration abstract class. Your migrations will derive from this class and implement two methods. You also need to define the Migration attribute with a unique identifier. Commonly, this identifier is just an incrementing value, although the attribute accepts an Int64, some people use a numbered date format such as yyyyMMdd. The significance of this number is for the ordering of your migrations. Lower numbers execute first and then larger. It also provides a way to target a specific migration. Your migration class that you create is where you define the migrations to execute. Migrations can be run out of sequence if they are checked in out of sequence. For example you may check in migration 1, 3 and 5 in one build, and migration 2 in a later build. Migration 2 will still get run even though it is not later than the most recent migration because it has not been run before. Since you define both a UP and DOWN for each migration, it's possible to move forward and backwards in migrations at any point in time. The only caveat is that migrating down is destructive as tables and/or rows are being deleted in the process. Be sure to have a backup first if you want to keep the data [Migration(1)] public class CreateUserTable : Migration { public override void Up() { Create.Table(\"Users\"); } public override void Down() { Delete.Table(\"Users\"); } } When you are migrating TO version 1 (if the database is empty for instance), then the migration code in the Up() method will be called creating a table called \"Users\" in the database. When you are migrating to a version BEFORE version 1 (for instance version 0), then the migration code in the Down() method will be called deleting the \"Users\" table from the database. Here's another sample migration that goes a little more in depth [Migration(1)] public class TestCreateAndDropTableMigration: Migration { public override void Up() { Create.Table(\"TestTable\") .WithColumn(\"Id\").AsInt32().NotNullable().PrimaryKey().Identity() .WithColumn(\"Name\").AsString(255).NotNullable().WithDefaultValue(\"Anonymous\"); Create.Table(\"TestTable2\") .WithColumn(\"Id\").AsInt32().NotNullable().PrimaryKey().Identity() .WithColumn(\"Name\").AsString(255).Nullable() .WithColumn(\"TestTableId\").AsInt32().NotNullable(); Create.Index(\"ix_Name\").OnTable(\"TestTable2\").OnColumn(\"Name\").Ascending() .WithOptions().NonClustered(); Create.Column(\"Name2\").OnTable(\"TestTable2\").AsBoolean().Nullable(); Create.ForeignKey(\"fk_TestTable2_TestTableId_TestTable_Id\") .FromTable(\"TestTable2\").ForeignColumn(\"TestTableId\") .ToTable(\"TestTable\").PrimaryColumn(\"Id\"); Insert.IntoTable(\"TestTable\").Row(new { Name = \"Test\" }); } public override void Down() { Delete.Table(\"TestTable2\"); Delete.Table(\"TestTable\"); } } Note that if you use SQL Server identity columns, you should also use FluentMigrator's WithIdentityInsert clause for inserting data. Diving further into FM, we look at the Fluent Interface to make more useful migrations."
  },
  "articles/maintenance-migrations.html": {
    "href": "articles/maintenance-migrations.html",
    "title": "Maintenance Migrations | FluentMigrator documentation",
    "keywords": "Maintenance Migrations Overview Maintenace Migration are a flexible way to apply logic on every migration run. They're flexible in that there are several \"stages\" the logic can be applied. Migration Stages BeforeAll : Migration will be run before all standard migrations. BeforeEach : Migration will be run before each standard migration. AfterEach : Migration will be run after each standard migration. BeforeProfiles : Migration will be run after all standard migrations, but before profiles. AfterAll : Migration will be run after all standard migrations and profiles. Use Cases In the FAQ , we demonstrate using Maintenance Migrations to create an \"application lock\" so that only one Migration Runner can run on a database at a time. Seeding test/development data. SQL Server-specific use cases that may potentially create ideas for users of other databases: Automatically refreshing SQL Server database views metadata are refreshed via sp_refreshview Fixing the broken dependencies on all objects so that database replication works. Syntax The following example will print \"Tag=[Development] Stage=[BeforeAll]\" when running the migration with --tag=Development . using FluentMigrator; using System; namespace YourCompany.YourProduct.Database.Maintenance { public class TagNames { public const string Development = nameof(Development); } [Tags(TagNames.Development)] [Maintenance(MigrationStage.BeforeAll, TransactionBehavior.None)] public class DevBeforeAll : ForwardOnlyMigration { public override void Up() { System.Console.WriteLine($\"Tag=[{TagNames.Development}] Stage=[{MigrationStage.BeforeAll}]\"); } } }"
  },
  "articles/faq-change-naming-conventions.html": {
    "href": "articles/faq-change-naming-conventions.html",
    "title": "High-Level Tasks | FluentMigrator documentation",
    "keywords": "FluentMigrator supports changing naming conventions for: Columns Constraints Indexes Sequences Schemas Auto Names Root Paths While FluentMigrator comes with reasonable naming conventions, some organizations may have strict standards. In such cases, overriding FluentMigrator's opinion may be desirable. High-Level Tasks Implement the IConventionSet interface (example: see below) Register the IConventionSet as singleton: services.AddSingleton<IConventionSet>(new YourConventionSet()) Example IConventionSet implementation public class YourConventionSet : IConventionSet { public YourConventionSet() : this(new DefaultConventionSet()) { } public YourConventionSet(IConventionSet innerConventionSet) { ForeignKeyConventions = new List<IForeignKeyConvention>() { /* This is where you do your stuff */ new YourCustomDefaultForeignKeyNameConvention(), innerConventionSet.SchemaConvention, }; ColumnsConventions = innerConventionSet.ColumnsConventions; ConstraintConventions = innerConventionSet.ConstraintConventions; IndexConventions = innerConventionSet.IndexConventions; SequenceConventions = innerConventionSet.SequenceConventions; AutoNameConventions = innerConventionSet.AutoNameConventions; SchemaConvention = innerConventionSet.SchemaConvention; RootPathConvention = innerConventionSet.RootPathConvention; } /// <inheritdoc /> public IRootPathConvention RootPathConvention { get; } /// <inheritdoc /> public DefaultSchemaConvention SchemaConvention { get; } /// <inheritdoc /> public IList<IColumnsConvention> ColumnsConventions { get; } /// <inheritdoc /> public IList<IConstraintConvention> ConstraintConventions { get; } /// <inheritdoc /> public IList<IForeignKeyConvention> ForeignKeyConventions { get; } /// <inheritdoc /> public IList<IIndexConvention> IndexConventions { get; } /// <inheritdoc /> public IList<ISequenceConvention> SequenceConventions { get; } /// <inheritdoc /> public IList<IAutoNameConvention> AutoNameConventions { get; } }"
  },
  "articles/db-functions.html": {
    "href": "articles/db-functions.html",
    "title": "Database functions | FluentMigrator documentation",
    "keywords": "Database functions It is possible to set the default value when creating or altering a column. To just set a value you can use the following fluent syntax: Create.Table(\"TestTable\").WithColumn(\"Name\").AsString().Nullable().WithDefaultValue(\"test\"); In addition, in the event you want to pass in arbitrary SQL to the WithDefaultValue method, you can do so using [raw sql](xref:raw-sql.md]: Create.Table(\"TestTable\").WithColumn(\"Name\").AsString().Nullable().WithDefaultValue(RawSql.Insert(\"SYSUTCDATETIME()\")); However, you can take advantage of some database functions to set the default value. The SystemMethods enum contains five database functions: Function Description NewGuid Creates a new GUID NewSequentialId Creates a new sequential GUID CurrentDateTime The current (local) timestamp CurrentDateTimeOffset The current (local) timestamp with time zone CurrentUTCDateTime The current (UTC) timestamp CurrentUser The current user name These are specific to each database, for example CurrentDateTime calls the GETDATE() function for Sql Server and the now() function for Postgres. By using WithDefault instead of WithDefaultValue, you can pass in one of the enum values. Create.Table(\"TestTable\").WithColumn(\"Created\").AsDateTime().Nullable().WithDefault(SystemMethods.CurrentDateTime); Function/Database support matrix Server NewGuid NewSequentialId CurrentDateTime CurrentDateTimeOffset CurrentUTCDateTime CurrentUser DB2 ☐ ☐ ☑ ☐ ☑ ☑ Firebird ☑ ☑ 1 ☑ ☐ ☐ ☐ Hana ☐ ☐ ☑ ☐ ☑ ☐ JET ☐ ☐ ☐ ☐ ☐ ☐ MySQL ☑ ☑ 1 ☑ ☐ ☑ ☑ Oracle ☑ ☑ 1 ☑ ☑ ☑ ☑ Postgres ☑ 2 ☑ 2 ☑ ☐ ☑ ☑ Redshift ☐ ☐ ☑ ☑ 3 ☑ ☑ SQLite ☐ ☐ ☑ ☐ ☑ ☐ SQL Anywhere ☑ ☑ 1 ☑ ☑ 3 ☑ ☑ SQL Server 2000 ☑ ☑ ☑ ☑ 4 ☑ ☑ SQL Server 2008 ☑ ☑ ☑ ☑ ☑ ☑ SQL Server CE ☑ ☑ ☑ ☑ 4 ☑ ☑ 1 Is the same as NewGuid 2 uuid-ossp extension is required 3 Implicitly contains the offset 4 Same as CurrentDateTime"
  },
  "articles/migration-runners.html": {
    "href": "articles/migration-runners.html",
    "title": "Migration runners | FluentMigrator documentation",
    "keywords": "Migration runners We have three migration runners you can choose from. Please use the in-process runner if possible. In-Process This is an example of using the in-process migration runner: using System; using System.Linq; using FluentMigrator.Runner; using FluentMigrator.Runner.Initialization; using Microsoft.Extensions.DependencyInjection; namespace test { class Program { static void Main(string[] args) { var serviceProvider = CreateServices(); // Put the database update into a scope to ensure // that all resources will be disposed. using (var scope = serviceProvider.CreateScope()) { UpdateDatabase(scope.ServiceProvider); } } /// <summary> /// Configure the dependency injection services /// </summary> private static IServiceProvider CreateServices() { return new ServiceCollection() // Add common FluentMigrator services .AddFluentMigratorCore() .ConfigureRunner(rb => rb // Add SQLite support to FluentMigrator .AddSQLite() // Set the connection string .WithGlobalConnectionString(\"Data Source=test.db\") // Define the assembly containing the migrations .ScanIn(typeof(AddLogTable).Assembly).For.Migrations()) // Enable logging to console in the FluentMigrator way .AddLogging(lb => lb.AddFluentMigratorConsole()) // Build the service provider .BuildServiceProvider(false); } /// <summary> /// Update the database /// </summary> private static void UpdateDatabase(IServiceProvider serviceProvider) { // Instantiate the runner var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); // Execute the migrations runner.MigrateUp(); } } } Migrate.exe (FluentMigrator.Console package) This is a console tool that works also with the .NET Framework outside of the .NET Core ecosystem. Visual Studio: Install with the package manager console NuGet: Install with the nuget.exe tool Install the package with: Install-Package FluentMigrator.Console Install the package with: nuget install FluentMigrator.Console -ExcludeVersion Now, you can find the tool in the path FluentMigrator[package-version]/tools/<target-framework>/[optional-platform/]Migrate.exe . Note The package-version is only part of the path when the tool was installed using the Visual Studio package manager console. Important Choose the correct target-framework . Otherwise, the tool might not be able to load your assembly. target-framework platform optional-platform exists? path net40 x86 yes tools/net40/x86/Migrate.exe net40 x64 yes tools/net40/x64/Migrate.exe net40 AnyCPU no tools/net40/Migrate.exe net45 x86 yes tools/net45/x86/Migrate.exe net45 x64 yes tools/net45/x64/Migrate.exe net45 AnyCPU no tools/net45/Migrate.exe net452 x86 yes tools/net452/x86/Migrate.exe net452 x64 yes tools/net452/x64/Migrate.exe net452 AnyCPU yes tools/net452/any/Migrate.exe Important On non-Windows platforms, you have to install/use mono. dotnet fm (FluentMigrator.DotNet.Cli tool) Important You need at least the .NET Core 2.1 preview 2 SDK for this tool. Install the dotnet-fm tool: dotnet tool install -g FluentMigrator.DotNet.Cli Execute the migration: dotnet fm migrate -p sqlite -c \"Data Source=test.db\" -a \".\\bin\\Debug\\netcoreapp2.1\\test.dll\" Tip You probably have to replace netcoreapp2.1 with the correct target framework. You can find it in the csproj file, XML element TargetFramework ."
  },
  "README.html": {
    "href": "README.html",
    "title": "FluentMigrator documentation | FluentMigrator documentation",
    "keywords": "FluentMigrator documentation This is the FluentMigrator documentation created with the docfx tool. You can find the published version of the documentation on fluentmigrator.github.io . Build status:"
  },
  "index.html": {
    "href": "index.html",
    "title": "Fluent migrations framework for .NET | FluentMigrator documentation",
    "keywords": "Fluent migrations framework for .NET Fluent Migrator is a migration framework for .NET much like Ruby on Rails Migrations. Migrations are a structured way to alter your database schema and are an alternative to creating lots of sql scripts that have to be run manually by every developer involved. Migrations solve the problem of evolving a database schema for multiple databases (for example, the developer's local database, the test database and the production database). Database schema changes are described in classes written in C# that can be checked into a version control system. How to use it Database-agnostic migrations: Quickstart Database-specific migrations: SQL Server Extensions Postgres Extensions Frequently Asked Questions FluentMigrator Comparison to Entity Framework Core Migrations What does it look like? This is an example of a database-agnostic migration: using FluentMigrator; namespace test { [Migration(20180430121800)] public class AddLogTable : Migration { public override void Up() { Create.Table(\"Log\") .WithColumn(\"Id\").AsInt64().PrimaryKey().Identity() .WithColumn(\"Text\").AsString(); } public override void Down() { Delete.Table(\"Log\"); } } } Current Release Release Notes Upgrade guides 3.1 to 3.2 3.0 to 3.1 2.x to 3.0 Supported databases For the current release these are the supported databases: Database Identifier Alternative identifier(s) Microsoft SQL Server 2019 SqlServer2016 (1) SqlServer Microsoft SQL Server 2017 SqlServer2016 (2) SqlServer Microsoft SQL Server 2016 SqlServer2016 SqlServer Microsoft SQL Server 2014 SqlServer2014 SqlServer Microsoft SQL Server 2012 SqlServer2012 SqlServer Microsoft SQL Server 2008 SqlServer2008 SqlServer Microsoft SQL Server 2005 SqlServer2005 SqlServer Microsoft SQL Server 2000 SqlServer2000 SqlServer Microsoft SQL Server Compact Edition (3) SqlServerCe SqlServer PostgreSQL Postgres PostgreSQL PostgreSQL 9.2 Postgres92 PostgreSQL92 PostgreSQL 10.0 PostgreSQL10_0 PostgreSQL PostgreSQL 11.0 PostgreSQL11_0 PostgreSQL MySQL 4 MySql4 MySql MySQL 5 MySql5 MySql, MariaDB Oracle Oracle Oracle (managed ADO.NET) OracleManaged Oracle Oracle (DotConnect ADO.NET) OracleDotConnect Oracle Microsoft JET Engine (Access) Jet SQLite Sqlite Firebird Firebird Amazon Redshift Redshift SAP Hana Hana SAP SQL Anywhere (4) SqlAnywhere16 SqlAnywhere DB2 DB2 DB2 iSeries DB2 iSeries DB2 (1) All integration tests ran without error against an SQL Server 2019 using the SqlServer2016 dialect. (2) All integration tests ran without error against an SQL Server 2017 using the SqlServer2016 dialect. (3) Support for Microsoft SQL Server Compact Edition is being dropped due to Microsoft end-of-life support date passing. (4) Support for SAP SQL Anywhere is being dropped due to SAP not supporting a .NET Core / .NET 5 database driver. More Information on FluentMigrator FAQ Sean Chambers on the Herding Code podcast"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "FluentMigrator API | FluentMigrator documentation",
    "keywords": "FluentMigrator API The most important part of the API is the migration runner . Getting started The starting point for every beginner of FluentMigrator is the Quickstart tutorial ."
  },
  "articles/technical/fluent-api-common.html": {
    "href": "articles/technical/fluent-api-common.html",
    "title": "Fluent API common parts | FluentMigrator documentation",
    "keywords": "IColumnTypeSyntax<TNext> --------+- AsAnsiString -+--------+-------------+---------------+-> TNext | | | | | | +- size -+- collation -+ | | | +- AsBinary -----+--------+-----------------------------+ | | | | | +- size -+ | | | +- AsBoolean -------------------------------------------+ | | +- AsByte ----------------------------------------------+ | | +- AsCurrency ------------------------------------------+ | | +- AsDate ----------------------------------------------+ | | +- AsDateTime ------------------------------------------+ | | +- AsDateTime2 -----------------------------------------+ | | +- AsDateTimeOffset -+-------------+--------------------+ | | | | | +- precision -+ | | | +- AsDecimal --------+--------------------------+-------+ | | | | | +- precision ------ scale -+ | | | +- AsDouble --------------------------------------------+ | | +- AsGuid ----------------------------------------------+ | | +- AsFixedLengthString --- size -----+-------------+----+ | | | | | +- collation -+ | | | +- AsFixedLengthAnsiString --- size -+-------------+----+ | | | | | +- collation -+ | | | +- AsFloat ---------------------------------------------+ | | +- AsInt16 ---------------------------------------------+ | | +- AsInt32 ---------------------------------------------+ | | +- AsInt64 ---------------------------------------------+ | | +- AsString -----+--------+-------------+---------------+ | | | | | | +- size -+- collation -+ | | | +- AsTime ----------------------------------------------+ | | +- AsXml --------+--------+-----------------------------+ | | | | | +- size -+ | | | +- AsCustom --- customType -----------------------------+ IColumnOptionSyntax<TNext,TNextFk> --------+- WithDefault --- method --------------------------------------+--> TNext | | +- WithDefaultValue --- value ----------------------------------+ | | +- WithColumnDescription --- description -----------------------+ | | +- Identity ----------------------------------------------------+ | | +- Indexed -----------------------------------------------------+ | | +- PrimaryKey -+--------+---------------------------------------+ | | | | | +- name -+ | | | +- Nullable ----------------------------------------------------+ | | +- NotNullable -------------------------------------------------+ | | +- Unique -----+--------+---------------------------------------+ | | | | +- name -+ | +- ForeignKey ---+-------------------------------------------+--+--> TNextFk | | | | | +-----------------------+- table --- column-+ | | | | | | +- name -+-+----------+-+ | | | | | | +- schema -+ | | | +- ReferencedBy -+-----------------------+- table --- column-+--+ | | +- name -+-+----------+-+ | | +- schema -+ IForeignKeyCascadeSyntax<TNext,TNextFk> --------+- OnDeleteOrUpdate --- rule ---> TNext | +- OnDelete --- rule -+---------> TNextFk | | +- OnUpdate --- rule -+"
  },
  "articles/obsolete/app-context.html": {
    "href": "articles/obsolete/app-context.html",
    "title": "ApplicationContext: Passing parameters to Migrations | FluentMigrator documentation",
    "keywords": "Caution The ApplicationContext is obsolete. Use dependency injection instead! Obsolete: ApplicationContext: Passing parameters to Migrations ApplicationContext is an object passed in by the Migration Runner that is available to migrations to be used as a switch. To set the ApplicationContext when running migrate.exe Run migrate.exe ... --context MyArgument . This will set the application context to the string MyArgument . To set the ApplicationContext when running migration in code Set migratorConsole.ApplicationContext to an arbitrary C# object, such as a string: migratorConsole.ApplicationContext = \"MyArgument\"; or when creating the RunnerContext : var migrationContext = new FluentMigrator.Runner.Initialization.RunnerContext(announcer) { ApplicationContext = \"MyArgument\" }; To use the ApplicationContext Inside your migration, you can access the context via this.ApplicationContext . So for instance: if ((string)this.ApplicationContext == \"MyArgument\") this.Delete.Column(\"BadColumn\").FromTable(\"MyTable\"); Alternative: DependencyInjection Just register your service and use it in your migration: interface IMyService { string MyStringData { get; } } class MyService : IMyService { public string MyStringData { get; set; } } static void Main() { var serviceProvider = new ServiceCollection() .AddFluentMigratorCore() // TODO: Configure database and connection .AddSingleton<IMyService>(new MyService() { MyStringData = \"MyArgument\" }) .BuildServiceProvider(); var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); // TODO: Use the runner } [Migration(1234)] public class MyMigration : ForwardOnlyMigration { private readonly IMyService _service; public MyMigration(IMyService service) { _service = service; } public void Up() { if (_service.MyStringData == \"MyArgument\") Delete.Column(\"BadColumn\").FromTable(\"MyTable\"); } }"
  },
  "articles/extensions/postgres-extensions.html": {
    "href": "articles/extensions/postgres-extensions.html",
    "title": "Postgres specific extensions | FluentMigrator documentation",
    "keywords": "FluentMigrator supports some extra functions that are specific to Postgres only. Adding the FluentMigrator.Runner assembly as a reference These extension methods are not included in the core dll so to get access them you have to add the FluentMigrator.Extensions.Postgres package in your migrations project. The final step is to add the following using to your migration class: using FluentMigrator.Postgres; Include column on index This extension allows you to include a column for an index. Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .Include(\"Name\"); Note: This feature was implement on Postgres 11, with you want to use it is necessary use Postgres11_0 or higher. var service = new ServiceCollection() // Add common FluentMigrator services .AddFluentMigratorCore() .ConfigureRunner(rb => rb // Add Postgres 11 support to FluentMigrator .AddPostgres11_0() .. ); Index method This extension allows you to choose a specific index method (B-tree (default), Hash, GiST, SP-GiST, GIN, and BRIN) for more information about index method see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingHash(); Or if you want more control over index method you could pass the index method by parameter: Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .Using(Algorithm.Gin); Notes: Dependend on the index method could or couldn't support some feature, for sample Hash index method doesn't support multi-column. For more information about index method limitation see here in Notes parts. Concurrently When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table. Whereas a standard index build locks out writes (but not reads) on the table until it's done. For more information about index method see here . Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .AsConcurrently(); Notes For to be able to use this feature is necessary remove the transaction from migrations, because PostgeSQLd doesn't support create concurrently index with transaction. Only Indicates not to recurse creating indexes on partitions, if the table is partitioned Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .AsOnly(); Null sorts Specifies that column should be sort before or after non-nulls. Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending().Nulls(NullSort.First); Nulls First Specifies that nulls sort before non-nulls. This is the default when DESC is specified. Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending().NullsFirst() Nulls Last Specifies that nulls sort after non-nulls. This is the default when DESC is not specified. Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending().NullsLast() Partial Indexes (WHERE/Filter) A partial index is an index built over a subset of a table; the subset is defined by a conditional expression (called the predicate of the partial index). The index contains entries only for those table rows that satisfy the predicate. For more information about index method see here . Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .Column(\"is_enable\").Ascending() .WithOptions() .Filter(\"is_enable is true\"); Index Storage Parameters Each index method has its own set of allowed storage parameters. For more information about index storageparameters see here Fillfactor The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods. Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .Fillfactor(100); Notes: In case you use Fillfactor without have select an index method we are going to assume that you are using B-Tree (the defautl index method) and the release B-Tree index storage. B-Tree The exclusive index storage parameters for B-Tree index method. Vacuum cleanup index scale factor Specifies the fraction of the total number of heap tuples counted in the previous statistics collection that can be inserted without incurring an index scan at the VACUUM cleanup stage. The value can range from 0 to 10_000_000_000. When vacuum_cleanup_index_scale_factor is set to 0, index scans are never skipped during VACUUM cleanup. The default value is 0.1. For more information aboutVacuum cleanup index scale factor see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingBTree() .VacuumCleanupIndexScaleFactor(12.0f); Note: This feature was implement on Postgres 11, if you want to use it is necessary use Postgres11_0 or higher. GiST The exclusive index storage parameters for GiST index method. Buffering Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not. For more information about Buffering see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingGist() .Buffering(GistBuffering.Auto) Note: This feature was implement on Postgres 10, if you want to use it is necessary use Postgres10_0. GIN The exclusive index storage parameters for GIN index method. Fastupdate Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). Because of that nature of GIN index, PostgreSQL add support for Fastupdate, where that is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. For more information about Fastupdate see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingGin() .FastUpdate() Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingGin() .DisableFastUpdate() Pending list limit Sets the maximum size of a GIN index's pending list, which is used when fastupdate is enabled. If the list grows larger than this maximum size, it is cleaned up by moving the entries in it to the index's main GIN data structure in bulk. If this value is specified without units, it is taken as kilobytes. The default is four megabytes (4MB). For more information about Pending list limit see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingGin() .PendingListLimit(1_000) Note: This feature was implement on Postgres 10, if you want to use it is necessary use Postgres10_0 or higher. BRIN The exclusive index storage parameters for BRIN index method. Pages per range Defines the number of table blocks that make up one block range for each entry of a BRIN index. The default is 128. For more information about BRIN index see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingBrin() .PagesPerRange(127) Note: This feature was implement on Postgres 10, if you want to use it is necessary use Postgres10_0 or higher. Autosummarize Defines whether a summarization run is invoked for the previous page range whenever an insertion is detected on the next one. For more information about BRIN index see here Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingBrin() .Autosummarize() Create.Index() .OnTable(\"TestTable\") .Column(\"Id\").Ascending() .WithOptions() .UsingBrin() .DisableAutosummarize() Note: This feature was implement on Postgres 10, if you want to use it is necessary use Postgres10_0 or higher."
  },
  "articles/extensions/sql-server-extensions.html": {
    "href": "articles/extensions/sql-server-extensions.html",
    "title": "SQL Server specific extensions | FluentMigrator documentation",
    "keywords": "FluentMigrator supports some extra functions that are specific to Sql Server only. Adding the FluentMigrator.Runner assembly as a reference These extension methods are not included in the core dll so to get access them you have to add the FluentMigrator.Extensions.SqlServer package in your migrations project. The final step is to add the following using to your migration class: using FluentMigrator.SqlServer; Constraint Clustering (Clustered or NonClustered) This extension allows you to specify a primary key or unique constraint as clustered or non-clustered. SQL Server tries do the following, unless you specify 'clustered' or 'nonclustered' in sql: Create a primary key with a 'clustered' index Create a unique constraint with a 'nonclustered' index Therefore, the most common usage pattern is likely to be along the lines of: Create a primary key with a 'nonclustered' index Create.PrimaryKey(\"PK\").OnTable(\"TestTable\").Column(\"Id\").NonClustered(); Create a unique constraint with a 'clustered' index Create.UniqueConstraint(\"UQ\").OnTable(\"TestTable\").Column(\"Name\").Clustered(); Note: You have to create the primary key index or unique constraint separately from the Create.Table expression to be able to specify them as clustered or non-clustered. Create a unique constraint on nullable columns using null value filter Note: SQL Server has a different approach to creating unique constraints on nullable columns than ANSI standard. Create.Index(\"UQ_NullFilter\") .OnTable(\"TestTable\").InSchema(\"dbo\") .OnColumn(\"Name\").Ascending() .WithOptions().Unique() .WithOptions().Filter(\"[Name] IS NOT NULL\"); This will generate the following T-SQL DDL statement: CREATE UNIQUE NONCLUSTERED INDEX [UQ_NullFilter] ON [dbo].[TestTable] ( [Name] ASC ) WHERE ([Name] IS NOT NULL) Create a column of SQL data type nvarchar(MAX) / varchar(MAX) Use int.MaxValue to represent infinite length strings. Create.Column(\"Name\").OnTable(\"TestTable\").AsString(int.MaxValue); Use .AsAnsiString(int.MaxValue) for varchar(MAX) : Create.Column(\"Name\").OnTable(\"TestTable\").AsAnsiString(int.MaxValue); Alternatively, you can define an extension method for use with Create.Table syntax, which would then be visible in the Visual Studio IntelliSense code completion dropdown: public static class ICreateTableColumnAsTypeSyntaxExtensions { public static ICreateTableColumnOptionOrWithColumnSyntax AsMaxString(this ICreateTableColumnAsTypeSyntax createTableColumnAsTypeSyntax) { return createTableColumnAsTypeSyntax.AsString(int.MaxValue); } } WithIdentityInsert If you want to turn on Identity Insert to be able to insert values into an identity column (see here for more details) then FluentMigrator has an extension method that supports this. Insert.IntoTable(\"Foo\") .WithIdentityInsert() .Row(new { id = 1, name = \"Foo 1\" }); Add Identity Column with Seed and Increment If you want to create an identity column and specify the seed (the id to start with) and an increment (how much the id value should increase when inserting new rows) then use this extension method: Create.Table(\"TestTable\") .WithColumn(\"Id\").AsInt32().Identity(100,1)"
  },
  "articles/migration/migration-attribute-custom.html": {
    "href": "articles/migration/migration-attribute-custom.html",
    "title": "Enforcing migration version numbering rules | FluentMigrator documentation",
    "keywords": "Enforcing migration version numbering rules Frequently, it is useful for a project to employ a specific system for migration version numbering. A useful technique for simplifying and encoding this system is with a custom attribute that inherits from MigrationAttribute . An example is below. This uses a system where the migration version is of the format BBYYYYMMDDHHMM, where BB is a branch, YYYY is year, MM is month, and so on. /// <summary> /// Mark all migrations with this INSTEAD of [Migration]. /// </summary> public class MyCustomMigrationAttribute : FluentMigrator.MigrationAttribute { public MyCustomMigrationAttribute(int branchNumber, int year, int month, int day, int hour, int minute, string author) : base(CalculateValue(branchNumber, year, month, day, hour, minute)) { this.Author = author; } public string Author { get; private set; } private static long CalculateValue(int branchNumber, int year, int month, int day, int hour, int minute) { return branchNumber * 1000000000000L + year * 100000000L + month * 1000000L + day * 10000L + hour * 100L + minute; } } A migration class that uses this attribute might look like this: [MyCustomMigration(author: \"Scott Stafford\", branchNumber: 12, year: 2012, month: 8, day: 7, hour: 14, minute: 01)] public class TestLcmpMigration : Migration { public override void Down() { /* ... */ } public override void Up() { /* ... */ } }"
  },
  "articles/migration/migration-auto-reversing.html": {
    "href": "articles/migration/migration-auto-reversing.html",
    "title": "Auto-reversing migrations | FluentMigrator documentation",
    "keywords": "Auto-reversing migrations Auto reversing migrations are migrations that only contain an up command and FluentMigrator figures out the down command. Create a migration class that inherits from AutoReversingMigration (instead of Migration ) to use this feature. [Migration(201207080104)] public class RenameTableWithSchema : AutoReversingMigration { public override void Up() { Rename.Table(\"TestTable2\").InSchema(\"TestSchema\").To(\"TestTable'3\"); } } FluentMigrator can automatically figure out the down command and revert the rename. However, not all expressions are supported for auto reversing. For example, using the Execute expression to execute an sql script is impossible to reverse. Expressions that are currently supported for auto reversing are: Create.Table Create.Column Create.Index Create.ForeignKey Create.Schema Delete.ForeignKey Rename.Table Rename.Column"
  },
  "articles/migration/migration-transaction-behavior.html": {
    "href": "articles/migration/migration-transaction-behavior.html",
    "title": "Migration transaction behavior | FluentMigrator documentation",
    "keywords": "Transaction modes for the migration runner There are two modes, Transaction-Per-Session and Transaction-Per-Migration. The default mode for FluentMigrator is Transaction-Per-Migration. Transaction-Per-Migration This mode means that each migration is run in its own transaction and allows selected migrations to be run with no transaction. This allows migrations to be able to do tasks like creating full-text indexes which cannot be run in a transaction. This mode can be used in combination with the new TransactionBehavior attribute. [Migration(201304210958, TransactionBehavior.None)] For this migration it will be run outside of a transaction. The default value for TransactionBehavior is Default which means the migration will be run in a transaction. Note Not all databases support \"Transactional Data Definition Language\" (Transactional DDL). Sybase and SQL Server support some version of Transactional DDL through Transact-SQL language, but there are some limitations around schema binding, user-defined types, and when \"names\" are bound/resolved. MySQL introducd Transactional DDL support in MySQL 8.0 as \" atomic DDL \". Transaction-Per-Session Up to this release, there has been one mode, Transaction-Per-Session. This means that if two migrations or more migrations are run together during the same task (e.g. migrate up or down) then this occurs in the same transaction and if one of the migrations fails then all the migrations are rolled back. Transaction-Per-Session is the old default and if you want to use this mode then there are switches for the Command-Line runner, MSBuild runner, or .NET CLI tool to enable it."
  },
  "articles/migration/migration-filter-tags.html": {
    "href": "articles/migration/migration-filter-tags.html",
    "title": "Fluent Interface | FluentMigrator documentation",
    "keywords": "Filter migrations run based on Tags Scenario: multiple database once had the same schema but over the years have had differences introduced. Because of this the majority of migrations, contained in one assembly, can be run against all the databases but at the same time you need to be able to filter certain migrations to run against specific databases based on the country (UK, DK, etc) and environment (Staging, Production, etc) it serves. To facilitate this you can tag migrations (much like cucumber scenarios) and then filter these by passing tags into the runner. A migration is then run if it has: No Tags OR Has Tags that match ALL those passed into the runner. Tags are assigned to migrations with an attribute/s: [Tags(\"DK\", \"NL\", \"UK\")] [Tags(\"Staging\", \"Production\")] [Migration(1)] public class DoSomeStuffToEuropeanStagingAndProdDbs : Migration { /* ... etc ... */ } Inheriting Migration Tags Tag inheritance can apply to both base classes (single-inheritance) and interfaces (multiple-inheritance). Scenario: If you have a multiple contexts for which changes need to be applied, it can be less error-prone to inherit tags from a base class. // Single-Inheritance of a base class [Tags(\"Development\", \"QA\", \"UAT\")] public class NonProductionMigration : Migration { /* ... etc ... */ } public class ApplySomeNonProductionChanges : NonProductionMigration { /* ... etc ... */ } Scenario: This is especially the case if you have common +AND+ divergent functionality that needs to be applied to multiple contexts. In this particular case, it is less error-prone to apply tags to one or more interfaces that may be combined. Consider the case of geographical database segregation whereby some functionality is applied to one or more instances based on geographical requirements. // tagged interfaces [Tags(\"AL\", \"TX\")] public interface IApplyToFeature1 { /* ... etc ... */ } [Tags(\"CA\", \"NV\")] public interface IApplyToFeature2 { /* ... etc ... */ } [Tags(\"AL\", \"NV\")] public interface IApplyToFeature3 { /* ... etc ... */ } [Tags(\"TX\")] public interface IApplyToFeatureWithSynchronousResponse { /* ... etc ... */ } [Tags(\"AL\", \"NV\")] public interface IApplyToFeatureWithAsynchronousQueueResponse { /* ... etc ... */ } [Tags(\"CA\")] public interface IApplyToFeatureWithAsynchronousBatchResponse { /* ... etc ... */ } // Inheritance of interfaces public interface IApplyToFeatureWithAsynchronousResponses : IApplyToFeatureWithAsynchronousBatchResponse, IApplyToFeatureWithAsynchronousQueueResponse { /* ... etc ... */ } public class ApplySomeChangeToFeature1 : Migration, IApplyToFeature1 { /* ... etc ... */ } public class ApplySomeChangeToFeatures2And3 : Migration, IApplyToFeature2, IApplyToFeature3 { /* ... etc ... */ } public class ApplySomeChangeToFeatureWithAsynchronousResponses : Migration, IApplyToFeatureWithAsynchronousResponses { /* ... etc ... */ } This allows for a Dev Ops pipeline that requires migrations based on a tag (in the case above, by state), and thus simplifying how to discern which migrations are applied based on that tag. This also means that creating a new database context for a state is a matter of deciding which features the new tag is associated with, and updating those relevant interfaces rather than having to add tags to all of the relevant migrations. Filtering IMigrationRunner Migrate.exe tool MSBuild task var serviceProvider = new ServiceCollection() .AddFluentMigratorCore() .ConfigureRunner(rb => rb .AddSqlServer2008() .WithGlobalConnectionString(\"server=.\\\\SQLEXPRESS;uid=testfm;pwd=test;Trusted_Connection=yes;database=FluentMigrator\") .ScanIn(typeof(DoSomeStuffToEuropeanStagingAndProdDbs).Assembly).For.Migrations()) .AddLogging(lb => lb.AddFluentMigratorConsole()) // Start of type filter configuration .Configure<RunnerOptions>(opt => { opt.Tags = new[] { \"UK\", \"Production\" } }) .BuildServiceProvider(false); var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); runner.MigrateUp(); And the tags are entered into the command line like so: (Migrations with UK AND Production tags executed) --tag UK --tag Production For the Msbuild runner, there is a Tags option and tags are passed in as a comma-separated string. <Migrate Database=\"sqlserver2008\" Connection=\"server=.\\SQLEXPRESS;uid=testfm;pwd=test;Trusted_Connection=yes;database=FluentMigrator\" Target=\"Migrations\" Tags=\"UK,Production\" />"
  },
  "articles/guides/upgrades/guide-3.1-to-3.2.html": {
    "href": "articles/guides/upgrades/guide-3.1-to-3.2.html",
    "title": "Upgrade Guide from 3.1 to 3.2 | FluentMigrator documentation",
    "keywords": "Upgrading from 3.1 to 3.2 This version contains mostly added features and fixed bugs. What is new? The most important changes are support for ORACLE 12c and the ability to disable removal of comments from SQL scripts. ORACLE 12c We're now supporting the new identity generator via Oracle-specific options. The maximum name length was also increased to 128 characters. Creating a identity column Create.Column(\"TestColumn\").OnTable(\"TestTable\").AsInt64().PrimaryKey().Identity(); Creating a identity column with options Create.Column(\"TestColumn\").OnTable(\"TestTable\").AsInt64().PrimaryKey() .Identity(OracleGenerationType.Always, startWith: 0, incrementBy: 1, minValue: 0, maxValue: long.MaxValue); The possible options for the generation are: Value Description OracleGenerationType.Always A value for the identity column is always generated by the database. Attepts to insert a value will cause an error. OracleGenerationType.ByDefault A value for the identity column is generated by the database when no value was given. Attepts to insert a NULL value will cause an error. OracleGenerationType.ByDefaultOnNull A value for the identity column is generated by the database when no value or a NULL value was given. Disable removal of comments There are now options for the external runners to disable removal of comments. Important The default will change from \"stripping\" to \"non-stripping\" of comments in version 4.0. dotnet-fm runner The option is --strip:false . This didn't work in 3.2.0 and was fixed in 3.2.1. msbuild runner The value to set is StripComments . console runner The option to disable stripping is --strip- . Allow maintenance objects without tags TODO Setting the default schema name dotnet-fm runner The option to set the default schema name is --default-schema-name=yourCustomSchema . msbuild runner The value to set is DefaultSchemaName . console runner The option to set the default schema name is --default-schema-name=yourCustomSchema . PostgreSQL before 9.2 The xml column type is now supported for DbType.Xml . PostgreSQL 9.2 We're now supporting the json column type for DbType.Object . SQL Server 2008+ The SPARSE column option can now be set using the .Sparse() extension method. Loading the IConventionSet from assemblies The external runners will automatically load the IConventionSet implementation from one of the specified assemblies. Migration constraints (preview) You're now able to decorate migrations with attributes derived from MigrationConstraintAttribute . Those attributes are used to decide if a migration should be applied. Currently, they aren't added to the VersionInfo table when they're not applied, but this might change in the future. CurrentVersionMigrationConstraintAttribute This ensures that a migration is only executed when the database had at least the given version before the start of the migration. This allows to skip some complex/timely conversion migrations. What is fixed? PR #920: Fix Oracle and SqlServer CE which execute queries in preview mode PR #926: Fix another case where queries where executed in preview mode on Oracle (DotConnect) PR #943: Properly quote byte array for SQLite Issue #859: Bug when using PoundSignSingleLineComment with SqlServer PR #999: Fixed bug in postgres description generator when generating full table name with schema Issue #957: FluentMigrator.DotNet.Cli --no-connection throws exception Issue #1001: Problems with transaction in Execute.WithConnection"
  },
  "articles/guides/upgrades/guide-3.0-to-3.1.html": {
    "href": "articles/guides/upgrades/guide-3.0-to-3.1.html",
    "title": "Upgrade Guide from 3.0 to 3.1 | FluentMigrator documentation",
    "keywords": "Upgrading from 3.0 to 3.1 This version contains mostly added features and fixed bugs. What is new? The WithMigrationsIn was well-meant, but not sufficient. We now provide an additional way to scan assemblies for the interesting stuff. New way to scan assemblies // Initialize you FluentMigrator (and other) services IServiceCollection services = ...; services .ConfigureRunner(rb => rb // Define the assembly containing the migrations .ScanIn(typeof(AddLogTable).Assembly).For.Migrations()); The interesting part here is the new ScanIn function which allows one to specify which assemblies should be scanned for the following parts: Migrations Version table metadata Embedded resources All the parts above One ScanIn can be used to target multiple parts: // Initialize you FluentMigrator (and other) services IServiceCollection services = ...; services .ConfigureRunner(rb => rb // Define the assembly containing the migrations .ScanIn(typeof(AddLogTable).Assembly) .For.Migrations() .For.EmbeddedResources()); It is also possible to use the assembly for everything: // Initialize you FluentMigrator (and other) services IServiceCollection services = ...; services .ConfigureRunner(rb => rb // Define the assembly containing the migrations .ScanIn(typeof(AddLogTable).Assembly).For.All()); Summary This allows explicit configuration of the scanned assemblies and avoids manual registration of an IAssemblySourceItem service, like this: services.AddSingleton<IAssemblySourceItem>(() => new AssemblySourceItem(GetType().Assembly)); IFilteringMigrationSource This interface allows filtering of all migration types without the need to instantiate them first. IVersionTableMetaDataSourceItem A new interface to specify multiple places to search for version table metadata. What has changed? #884 : Embedded script cannot be found in assemblies on .NET Core #888 : VersionTable not changed after upgrading to 3.0 IEmbeddedResourceProvider can be registered multiple times (required for the new ScanIn feature) Query IConfigurationRoot for the connection string if IConfiguration couldn't be found dotnet-fm now uses the Oracle beta ADO.NET driver Oracle Beta ADO.NET driver Oracle plans to release a non-beta version of the driver in Q3, but it's the only Oracle driver that works under Linux/MacOS. The console tool ( Migrate.exe ) is more Windows-centric and will therefore keep using the standard Oracle ADO.NET library. The dotnet-fm is mostly used on non-Windows platforms and is therefore predestined to use the new beta driver. The statement from Oracle can be found on the Oracle website . The console tool will switch to the new driver when it becomes stable. Dependency injection related changes Some services are now registered as \"Scoped\" to allow the reconfiguration of the connection string/used database at run-time. Applies to Connection string Processor/generator selection Type filters Changes The following option classes are now resolved using IOptionSnapshot<T> : ProcessorOptions SelectingProcessorAccessorOptions SelectingGeneratorAccessorOptions TypeFilterOptions The following services are now scoped instead of singleton: IVersionTableMetaDataAccessor IVersionTableMetaData IMigrationSource IMigrationInformationLoader The MigrationSource now consumes all registered IMigrationSourceItem instances. What is fixed? #877 : Connection specific information should be resolved as scoped Also: #882 #886 : Using profiles in 3.x versions #892 : Nullable types are not supported in MSBuild runner"
  },
  "articles/guides/upgrades/guide-2.0-to-3.0.html": {
    "href": "articles/guides/upgrades/guide-2.0-to-3.0.html",
    "title": "Upgrade Guide from 2.0 to 3.0 | FluentMigrator documentation",
    "keywords": "Upgrading from 2.x to 3.0 The upgrade from 2.x to 3.0 should be very smooth, because the API was kept mostly unchanged. What is new? FluentMigrator now uses dependency injection and other standard libraries from the ASP.NET Core project extensively. This results in a simpler API, well-defined extension points and in general more flexibility. New in-process runner initialization var serviceProvider = new ServiceCollection() // Logging is the replacement for the old IAnnouncer .AddLogging(lb => lb.AddFluentMigratorConsole()) // Registration of all FluentMigrator-specific services .AddFluentMigratorCore() // Configure the runner .ConfigureRunner( builder => builder // Use SQLite .AddSQLite() // The SQLite connection string .WithGlobalConnectionString(\"Data Source=test.db\") // Specify the assembly with the migrations .WithMigrationsIn(typeof(MyMigration).Assembly)) .BuildServiceProvider(); // Put the database update into a scope to ensure // that all resources will be disposed. using (var scope = serviceProvider.CreateScope()) { // Instantiate the runner var runner = scope.ServiceProvider.GetRequiredService<IMigrationRunner>(); // Execute the migrations runner.MigrateUp(); } dotnet-fm as global .NET Core CLI tool The dotnet-fm tool is now a global tool and therefore requires the .NET Core 2.1-preview2 tooling. This allows the usage of dotnet fm migrate from other directories than the project directory. Connection string handling changes The library assumes that in ProcessorOptions.ConnectionString is either a connection string or a connection string identifier. This are the steps to load the real connection string. Queries all IConnectionStringReader implementations When a connection string is returned by one of the readers, then this connection string will be used When no connection string is returned, try reading from the next IConnectionStringReader When no reader returned a connection string, then return ProcessorOptions.ConnectionString The connection string stored in ProcessorOptions.ConnectionString might be overridden by registering the IConnectionStringReader instance PassThroughConnectionStringReader as scoped service. When no connection string could be found, the SelectingProcessorAccessor returns a ConnectionlessProcessor instead of the previously selected processor. Custom migration expression validation There is a new service IMigrationExpressionValidator with a default implementation DefaultMigrationExpressionValidator that validates the migration expressions before executing them. This feature allows - for example - forbidding data deletions in a production environment. Using System.ComponentModel.DataAnnotations for validation Breaking Changes Version 3.0 dropped support for all .NET Framework versions below 4.6.1 and the timeout values are now stored as TimeSpan rather than an int (of seconds). Minimum: .NET Framework 4.6.1 Dropping the support for all .NET Framework versions below 4.6.1 was required, because the package now relies on the following libraries: Microsoft.Extensions.DependencyInjection Microsoft.Extensions.Options Microsoft.Extensions.Logging Microsoft.Extensions.Configuration ProcessorOptions.Timeout is now a TimeSpan This change is part of the ongoing effort to make the API easier to understand, because it might not be clear if an int timeout is the timeout in milliseconds, seconds, et cetera. Previously the int value corresponded to seconds. ICanBeValidated not used anymore The library now uses System.ComponentModel.DataAnnotations for validation - for example the [Required] attribute for expression fields that are - one might've guessed it - required. MigrationGeneratorFactory not used anymore The selection of the SQL generator happens using the IGeneratorAccessor service. MigrationProcessorFactoryProvider not used anymore The selection of the migration processor is done with the IProcessorAccessor service. Obsolete API Due to the introduction of dependency injection, some important migration runner related parts of the API have been deprecated. This section convers this topic and shows how to switch to the new dependency injection based API. Migration runner initialization This section shows the runner initialization both with dependency injection and with the IRunnerContext . New (with dependency injection) Obsolete (with IRunnerContext ) var serviceProvider = new ServiceCollection() // Logging is the replacement for the old IAnnouncer .AddLogging(lb => lb.AddFluentMigratorConsole()) // Registration of all FluentMigrator-specific services .AddFluentMigratorCore() // Configure the runner .ConfigureRunner( builder => builder // Use SQLite .AddSQLite() // The SQLite connection string .WithGlobalConnectionString(\"Data Source=test.db\") // Specify the assembly with the migrations .WithMigrationsIn(typeof(MyMigration).Assembly)) .BuildServiceProvider(); The runner can now be created and used with: // Put the database update into a scope to ensure // that all resources will be disposed. using (var scope = serviceProvider.CreateScope()) { // Instantiate the runner var runner = scope.ServiceProvider.GetRequiredService<IMigrationRunner>(); // Execute the migrations runner.MigrateUp(); } // Create the announcer to output the migration messages var announcer = new ConsoleAnnouncer(); // Processor specific options (usually none are needed) var options = new ProcessorOptions(); // Use SQLite var processorFactory = new SQLiteProcessorFactory(); // Initialize the processor using (var processor = processorFactory.Create( // The SQLite connection string \"Data Source=test.db\", announcer, options)) { // Configure the runner var context = new RunnerContext(announcer); // Create the migration runner var runner = new MigrationRunner( // Specify the assembly with the migrations typeof(MyMigration).Assembly, context, processor); // Run the migrations runner.MigrateUp(); } Differences explained Dependency Injection Allows fluent configuration Uses standard libraries Dependency Injection Options Logging Uses pluggable APIs May use a different DI container under the hood (AutoFac, etc...) May use standard logging frameworks (log4net, nlog, etc...) Obsolete API Clunky Re-inventing the wheel IAnnouncer The IAnnouncer interface (and its implementations) were replaced by ILogger and its implementations. Logger registration You can comfortably register the default FluentMigratorConsoleLogger : var serviceProvider = new ServiceCollection() .AddLogging(lb => lb.AddFluentMigratorConsole()) .BuildServiceProvider(); Configuring the logger output Warning Loggers derived from FluentMigratorLogger may use other logger option classes! Enabling output of elapsed time var serviceProvider = new ServiceCollection() .AddLogging(lb => lb.AddFluentMigratorConsole()) .Configure<FluentMigratorLoggerOptions>(cfg => { cfg.ShowElapsedTime = true; }) .BuildServiceProvider(); Enabling output of SQL Important Logging the SQL messages might be a security risk. Don't store sensitive data unhashed/unencrypted! var serviceProvider = new ServiceCollection() .AddLogging(lb => lb.AddFluentMigratorConsole()) .Configure<FluentMigratorLoggerOptions>(cfg => { cfg.ShowSql = true; }) .BuildServiceProvider(); Logger usage You don't use the loggers directly any more. Instead, you just create a constructor parameter with a type of ILogger or ILogger . public class MyMigration : ForwardOnlyMigration { private readonly ILogger<MyMigration> _logger; public MyMigration(ILogger<MyMigration> logger) { _logger = logger; } public void Up() { _logger.LogInformation(\"Creating Up migration expressions\"); } } Other loggers There are several other loggers, like: LogFileFluentMigratorLoggerProvider for logging SQL statements into a file SqlScriptFluentMigratorLoggerProvider for logging SQL statements into a TextWriter Registration of LogFileFluentMigratorLoggerProvider var serviceProvider = new ServiceCollection() .AddSingleton<ILoggerProvider, LogFileFluentMigratorLoggerProvider>() .Configure<LogFileFluentMigratorLoggerOptions>(opt => { opt.OutputFileName = \"sqlscript.sql\"; }) .BuildServiceProvider(); IMigrationRunnerConventions.GetMigrationInfo This function was replaced by IMigrationRunnerConventions.GetMigrationInfoForMigration , because the instantiation will be done using the dependency injection framework. IProfileLoader.ApplyProfiles This function was replaced by IProfileLoader.ApplyProfiles(IMigrationRunner) to avoid circular dependencies. IProfileLoader.FindProfilesIn(IAssemblyCollection, String) ) This function is not used anymore. IMigrationProcessorOptions This interface is not used anymore. We use ProcessorOptions instead. IMigrationProcessorFactory The factories aren't needed anymore. The registered services provide everything that they need for their configuration. IRunnerContext and RunnerContext The properties of this interface/class were refactored into several classes. Properties moved into RunnerOptions ApplicationContext ( obsolete! ) AllowBreakingChange NoConnection Profile StartVersion Steps Tags Task TransactionPerSession Version Properties moved into ProcessorOptions ConnectionString PreviewOnly ProviderSwitches Timeout Properties moved into TypeFilterOptions Namespace NestedNamespaces Properties moved into AppConfigConnectionStringAccessorOptions Warning This class only works under the full .NET Framework and is marked as obsolete! Provide access to an IConfiguration service. The FluentMigrator library will use it to call the GetConnectionString extension method. ConnectionStringPath ➔ ConnectionStringConfigPath Properties moved into SelectingProcessorAccessorOptions Database ➔ ProcessorId Properties moved into AssemblySourceOptions Targets ➔ AssemblyNames Properties with no direct replacement Announcer : Get your ILogger with dependency injection instead StopWatch : Get your IStopWatch with dependency injection instead WorkingDirectory This is set directly by the creation of a DefaultConventionSet and adding it as singleton to the service collection. var conventionSet = new DefaultConventionSet(defaultSchemaName: null, WorkingDirectory); services.AddSingleton<IConventionSet>(conventionSet) DefaultSchemaName This is set directly by the creation of a DefaultConventionSet and adding it as singleton to the service collection. var conventionSet = new DefaultConventionSet(DefaultSchemaName, workingDirectory: null); services.AddSingleton<IConventionSet>(conventionSet) CompatabilityMode renamed to CompatibilityMode The spelling has been fixed. ApplicationContext It is not needed anymore due to the dependency injection providing all services one may need. ManifestResourceNameWithAssembly replaced by ValueTuple This class was overkill. MigrationGeneratorFactory This isn't needed anymore, because all factories must be added dynamically using the ConfigureRunner extension method. Example: var serviceProvider = new ServiceCollection() // Registration of all FluentMigrator-specific services .AddFluentMigratorCore() // Configure the runner .ConfigureRunner( builder => builder // Add database support .AddSQLite() .AddSqlServer2008() .AddFirebird() /* TODO: More configuration */ ) /* TODO: Add more services */ .BuildServiceProvider(); Selecting the database The key is the IProcessorAccessor service and its default implementation SelectingProcessorAccessor , which is configured using the SelectingProcessorAccessorOptions . Note When the SelectingProcessorAccessorOptions aren't configured, then the value from the SelectingGeneratorAccessorOptions is used. Note When neither a processor nor generator ID was specified, then the added processor will be used - but only where there is only one! When no processor or more than one was specified, then an exception gets thrown. var serviceProvider = new ServiceCollection() // Registration of all FluentMigrator-specific services .AddFluentMigratorCore() // Configure the runner .ConfigureRunner( builder => builder // Add database support .AddSQLite() .AddSqlServer2008() .AddFirebird() /* TODO: More configuration */ ) .Configure<SelectingProcessorAccessorOptions>(cfg => { // Selects SQLite from the set of supported databases cfg.ProcessorId = \"sqlite\"; }) /* TODO: Add more services */ .BuildServiceProvider(); MigrationProcessorFactoryProvider This isn't needed anymore, because all processor factory providers must be added dynamically using the ConfigureRunner extension method. You can find an example above . Selecting the database The key is the IGeneratorAccessor service and its default implementation SelectingGeneratorAccessor , which is configured using the SelectingGeneratorAccessorOptions . Note When the SelectingGeneratorAccessorOptions aren't configured, then the value from the SelectingProcessorAccessorOptions is used. Note When neither a generator nor processor ID was specified, then the added generator will be used - but only where there is only one! When no generator or more than one was specified, then an exception gets thrown. var serviceProvider = new ServiceCollection() // Registration of all FluentMigrator-specific services .AddFluentMigratorCore() // Configure the runner .ConfigureRunner( builder => builder // Add database support .AddSQLite() .AddSqlServer2008() .AddFirebird() /* TODO: More configuration */ ) .Configure<SelectingGeneratorAccessorOptions>(cfg => { // Selects SQLite from the set of supported databases cfg.GeneratorId = \"sqlite\"; }) /* TODO: Add more services */ .BuildServiceProvider(); ITypeMap.GetTypeMap(DbType, int, int) Sometimes, it is possible that a given database type needs a precision of 0, so we cannot use 0 an indicator for an unspecified value anymore. Therefore, we provide an overload using nullable integer values . IDbFactory The implementations will remain, but the interface will be gone. ICanBeValidated The library now uses System.ComponentModel.DataAnnotations for validation - for example the [Required] attribute for expression fields that are - one might've guessed it - required. MigrationRunner.MaintenanceLoader is read-only Don't set the maintenance loader directly. Just register your own as a service. FAQ How do I use my own IConventionSet (or other service)? Just register them as your own service. Service Scope IConventionSet Singleton IAssemblyLoadEngine Singleton IAssemblySource Singleton IMaintenanceLoader Singleton IMigrationSource Singleton"
  },
  "articles/guides/upgrades/guide-1.6-to-2.0.html": {
    "href": "articles/guides/upgrades/guide-1.6-to-2.0.html",
    "title": "Upgrade Guide from 1.6 to 2.0 | FluentMigrator documentation",
    "keywords": "Upgrading from 1.6 to 2.0 What is new? FluentMigrator finally gained .NET Standard 2.0 support and added several new database and migration expression features. .NET Standard 2.0 This finally allows the usage of FluentMigrator together with ASP.NET Core 2.0! New databases SAP SQL Anywhere 16 With Unique Constraints: Non-Distinct NULL support Microsoft SQL Server 2016 Oracle MySQL 5 Amazon Redshift (experimental) Several enhancements MySQL ALTER DEFAULT , DROP DEFAULT support SQL Server 2005 WITH (ONLINE=ON/OFF) support 64 bit identity support SQL Server 2008 Unique Constraints: Non-Distinct NULL support Firebird New provider option: Force Quote=true to enforce quotes SQLite Foreign key support Streamlined table/index schema quoting Types: DateTime2 support Expression: IfDatabase: Predicate support IfDatabase: Method delegation support Index: Creation with non*key columns Conventions: Default schema name support SetExistingRowsTo supports SystemMethods Insert/Update/Delete: DbNull support Passing arguments to embedded SQL scripts Runner: TaskExecutor: HasMigrationsToApply support Case insensitive arguments support StopOnError flag What did change? DB-specific code moved The database specific code is now in its own assembly (one per database family). This will allow trimming dependencies in the future. MySQL announcing SQL scripts Some other DB processors already do this. Runner improvements Better error messages ListMigrations: showing (not applied) for unapplied migrations Show (BREAKING) for migrations with breaking changes MSBuild task is available as separate package (with custom .targets file) Use provider default command timeout when no global timeout is set Breaking changes DB-specific extensions The extension methods are now in their own assembly and namespace (e.g. for SqlServer - FluentMigrator.Extensions.SqlServer ). .NET Framework 3.5 support removed We now require at least .NET Framework 4.0. NAnt build runner removed NAnt itself isn't a living project anymore."
  },
  "articles/guides/upgrades/guide-3.2-to-4.0.html": {
    "href": "articles/guides/upgrades/guide-3.2-to-4.0.html",
    "title": "Upgrade Guide from 3.2 to 4.0 | FluentMigrator documentation",
    "keywords": "Upgrading from 3.2 to 4.0 This version contains mostly added features and fixed bugs. What is new? The most important changes are support for Microsoft.Data.Sqlite 6.0.x and the improved support for modern SQLite development."
  },
  "articles/guides/overview.html": {
    "href": "articles/guides/overview.html",
    "title": "FluentMigrator Guides | FluentMigrator documentation",
    "keywords": "This is a collection of guides around FluentMigrator. For beginners Getting Started For contributors How to contribute For upgrades 1.6 to 2.0 2.x to 3.0 3.0 to 3.1 3.1 to 3.2"
  },
  "articles/guides/contribution.html": {
    "href": "articles/guides/contribution.html",
    "title": "How to contribute | FluentMigrator documentation",
    "keywords": "How to contribute Fork on GitHub Create a branch Code (and add tests) Create a pull request on GitHub Target the develop branch for API-breaking changes Target the master branch for non-API-breaking changes and/or hotfixes Get the pull request merged Done How to build the code Note You must install mono on non-Windows platforms! dotnet build FluentMigrator.sln How to test the code Windows dotnet test test\\FluentMigrator.Tests\\FluentMigrator.Tests.csproj Linux, MacOS dotnet test test/FluentMigrator.Tests/FluentMigrator.Tests.csproj --filter \"TestCategory!=NotWorkingOnMono\" Enabling integration tests Only integration tests for two databases are enabled by default: SQL Server Compact Edition Only runs on Windows due to inability to load the needed DLLs SQLite This requires an installed Mono.Data.Sqlite package on Linux Every database can be configured using the dotnet user-secrets tool. Enabling PostgreSQL integration tests might look like this: Create a user fluentmigrator with password fluentmigrator Add a database FluentMigrator with the owner fluentmigrator Type the following instructions: # change into the test project directory cd test/FluentMigrator.Tests # Set the PostgreSQL connection string dotnet user-secrets set \"TestConnectionStrings:Postgres:ConnectionString\" \"Server=127.0.0.1;Port=5432;Database=FluentMigrator;User Id=fluentmigrator;Password=fluentmigrator\" # Enable the PostgreSQL integration tests dotnet user-secrets set \"TestConnectionStrings:Postgres:IsEnabled\" True When you run the unit tests, the integration tests for PostgreSQL are run as well. How to create NuGet packages dotnet pack ./FluentMigrator.sln --output \"absolute-path-to-output-directory\" ReSharper/Rider specific support There is a new template ctorc which creates a StyleCop-compatible constructor summary. Code style Please use an editor that supports the .editorconfig and/or the ReSharper/Rider settings FluentMigrator.sln.DotSettings . Generic Use spaces for indention Add a \"new line\" character when the last line is not empty Remove trailing whitespace characters For C# Indent size is 4 characters Use var for built-in types Use var when the type is apparent Prefer braces Sort using directives System using directives first Empty line between using directive groups Line break before open brace Add a license header region to every *.cs file #region License // // Copyright (c) 2018, Fluent Migrator Project // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // #endregion"
  },
  "articles/runners/dotnet-fm.html": {
    "href": "articles/runners/dotnet-fm.html",
    "title": "dotnet-fm tool | FluentMigrator documentation",
    "keywords": "The dotnet-fm tool Installation dotnet tool install -g FluentMigrator.DotNet.Cli Running You can run the tool with dotnet fm or dotnet-fm . Use the latter version if the former doesn't work due to a .NET Core CLI tool bug. Command structure dotnet-fm -+- list -+- migrations = List applied and pending migrations | +- processors = List all available processors +- migrate = Apply all migrations | +- up = Apply migrations up to given version (inclusive) | +- down = Apply migrations down to given version (exclusive) +- rollback = Rollback the last migration applied | +- all = Rollback all migrations | +- by = Rollback by <n> steps | +- to = Rollback to given version +- validate --- versions = Validate order of applied migrations list processors Shows all available processor identifiers to be used by the -p or --processor command line switch. .NET Runtime related switches --allowDirtyAssemblies switch Overrides the default .NET Assembly Loading logic, allowing you to load assemblies written for other versions of the .NET runtime. This is primarily intended for developers working on preview releases of the next version of the .NET runtime, but can be used by others as a workaround for assembly not found errors. In particular, it is possible to have a \"diamond dependency\" where some dependencies have higher assembly versions than the one FluentMigrator uses. For example, suppose FluentMigrator.DotNet.Cli ships with a particular version of System.ComponentModel.DataAnnotations. Further suppose that you have a private enterprise nuget package repository that has re-usable FluentMigrator extension methods, which transitively references a different verison of System.ComponentModel.DataAnnotations. There are only two possible ways you can call such an extension method: (1) implement your own FluentMigrator.DotNet.Cli tool and directly package your migrations DLL with the tool so that the MSBuild Microsoft.NET.Sdk correctly builds a project.deps.json used to resolve the right assembly (2) use this --allowDirtyAssemblies switch. As another example, suppose FluentMigrator has not yet shipped a .NET vNext compatible binary, but you want to work with that binary. The --allowDirtyAssemblies switch will help resolve the System.Runtime assembly. Connection related commands The following commands need a processor id and/or a connection: dotnet-fm list migrations dotnet-fm migrate dotnet-fm rollback dotnet-fm validate -c|--connection <CONNECTION_STRING> The connection string itself to the server and database you want to execute your migrations against. --no-connection Indicates that migrations will be generated without consulting a target database. Should only be used when generating an output file. -p|--processor <PROCESSOR_NAME> The kind of database you are migrating against. Available choices can be shown with list processors . -s|--processor-switches <PROCESSOR_SWITCHES> Database processor specific switches, e.g.: Firebird: Force Quote=true Oracle: QUOTEDIDENTIFIERS=TRUE --preview Only output the SQL generated by the migration - do not execute it. Default is false. -V|--verbose Show the SQL statements generated and execution time in the console. Default is false. --profile <PROFILE> The profile to run after executing migrations. --context <CONTEXT> (obsolete) Set ApplicationContext to the given string. --timeout <TIMEOUT_SEC> Overrides the default database command timeout of 30 seconds. -o|--output=<FILENAME> Output generated SQL to a file. Default is no output. A filename may be specified, otherwise [targetAssemblyName].sql is the default. -a|--assembly <ASSEMBLY_NAME> The assemblies containing the migrations you want to execute. -n|--namespace <NAMESPACE> The namespace contains the migrations you want to run. Default is all migrations found within the Target Assembly will be run. --nested Whether migrations in nested namespaces should be included. Used in conjunction with the namespace option. --start-version The specific version to start migrating from. Only used when NoConnection is true. Default is 0. --working-directory <WORKING_DIRECTORY> The directory to load SQL scripts specified by migrations from. -t|--tag Filters the migrations to be run by tag. -b|--allow-breaking-changes Allows execution of migrations marked as breaking changes. rollback and migrate specific parameters -m|--transaction-mode <MODE> Overrides the transaction behavior of migrations, so that all migrations to be executed will run in one transaction. Allowed values are: Migration Session rollback all Reverts all migrations. rollback by <steps> Reverts the last <steps> migrations. rollback to <version> Reverts all migrations down to (and excluding) <version> . migrate up Applies the found migrations. -t|--target <TARGET_VERSION> The specific version to migrate to (inclusive). migrate down Applies the found migrations. -t|--target <TARGET_VERSION> The specific version to revert to (exclusive). --strip:<true|false> Whether comments should be stripped from SQL text prior to executing migration on server. Default is true; false will become the default in 4.x. Examples List all available processors dotnet fm list processors List applied and pending migrations dotnet fm list migrations -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll Apply all migrations dotnet fm migrate -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll Apply migrations up to given version (inclusive) dotnet fm migrate -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll up -t 20090906205342 Apply migrations down to given version (exclusive) dotnet fm migrate -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll down -t 20090906205342 Rollback the last migration applied dotnet fm rollback -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll Rollback to given version dotnet fm rollback -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll to 20090906205342 Rollback by <n> steps dotnet fm rollback -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll by 1 Rollback all migrations dotnet fm rollback -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll all Validate order of applied migrations dotnet fm validate versions -p sqlite -c \"Data Source=test.db\" -a FluentMigrator.Example.Migrations.dll"
  },
  "articles/raw-sql.html": {
    "href": "articles/raw-sql.html",
    "title": "Raw SQL helper | FluentMigrator documentation",
    "keywords": "Raw SQL helper When using the Insert.IntoTable expression, or when setting the default column value, all row data that is a string is quoted and saved in the database. If you want to use an sql expression instead then the RawSql helper class is what you need. For example, if I want to use a Microsoft SQL Server function like CURRENT_USER and try to insert like this: Insert.IntoTable(\"Users\").Row(new { Username = \"CURRENT_USER\" }); The result will be that the Username column will get the value CURRENT_USER as a string. To execute the function you can use the RawSql.Insert method like this: Insert.IntoTable(\"User\").Row(new { Username = RawSql.Insert(\"CURRENT_USER\") }); This will result in the Username column being set to the current username. Be aware that by using an sql server specific function like CURRENT_USER that this expression is not portable anymore and will not work against another database (like PostgreSQL)."
  },
  "articles/glossary.html": {
    "href": "articles/glossary.html",
    "title": "Glossary | FluentMigrator documentation",
    "keywords": "Expression See: Migration Expression Maintenance Those are migrations that should always be executed at a specified stage. Warning Maintenance migrations are always run at the given stage when selected. Note A migration must have: public visibility IMigration as implemented interface (The Migration class already implements it) MaintenanceAttribute Migration Stages BeforeAll : Migration will be run before all standard migrations. BeforeEach : Migration will be run before each standard migration. AfterEach : Migration will be run after each standard migration. BeforeProfiles : Migration will be run after all standard migrations, but before profiles. AfterAll : Migration will be run after all standard migrations and profiles. Migration A migration is a database modification usually applied within its own transaction. Note A migration must have: public visibility IMigration as implemented interface (The Migration class already implements it) MigrationAttribute Migration Expression An expression created from within a migration that gets used to produce an SQL statement (using a migration generator ) that gets executed by a migration processor . A migration expression always implements IMigrationExpression . Migration Generator Translates an expression created from within a migration to one or more SQL statements. A migration generator always implements IMigrationGenerator . Migration Processor Passes the expressions to a migration generator and then executes the resulting SQL statements. A migration processor always implements IMigrationProcessor . Profile A profile is used to selectively apply migrations. Warning Profiles are always run when selected. Note A profile must have: public visibility IMigration as implemented interface (The Migration class already implements it) ProfileAttribute"
  },
  "articles/profiles.html": {
    "href": "articles/profiles.html",
    "title": "Profiles | FluentMigrator documentation",
    "keywords": "Profiles Note While Profiles are not deprecated or obsolete, they have been largely deprecated in favor of Maintenance Migrations. Profiles are only runnable at a particular point in time, whereas Maintenance Migrations have several different stages at which they can be applied, and are thus more flexible. Additionally, Maintenance Migrations can work with Tags to mimic the effect of a Profile Name. Profiles are used to selectively apply migrations depending on a command line option, or build script attribute. For instance, you may want to run the \"Development\" profile only in your Dev environment, and run the \"Testing\" profile in your Testing environment. Profiles will always be run if you specify them. Normally, these are useful to always put test/sample seed data in when dropping/refreshing development and testing environments. In production you would rarely want to continually insert the same data more than once. [Profile(\"Development\")] public class CreateDevSeedData : Migration { public override void Up() { Insert.IntoTable( \"User\" ).Row( new { Username = \"devuser1\", DisplayName = \"Dev User\" }); } public override void Down() { //empty, not using } } Now that you have migrations and profiles defined, you can use Migration Runners to apply changes to your database."
  },
  "api/v2.x/index.html": {
    "href": "api/v2.x/index.html",
    "title": "API for version 2.x | FluentMigrator documentation",
    "keywords": "API for version 2.x Using the in-process runner // Create the announcer to output the migration messages var announcer = new ConsoleAnnouncer(); // Processor specific options (usually none are needed) var options = new ProcessorOptions(); // Use SQLite var processorFactory = new SQLiteProcessorFactory(); // Initialize the processor using (var processor = processorFactory.Create( // The SQLite connection string \"Data Source=test.db\", announcer, options)) { // Configure the runner var context = new RunnerContext(announcer); // Create the migration runner var runner = new MigrationRunner( // Specify the assembly with the migrations typeof(MyMigration).Assembly, context, processor); // Run the migrations runner.MigrateUp(); }"
  }
}